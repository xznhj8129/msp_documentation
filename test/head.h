/*
 * Auto-generated by gen_msp_headers.py. Do not edit by hand.
 * This header mirrors the MSP message payloads defined in a JSON spec.
 *
 * It is a reference-only declaration set. No encode/decode here.
 */

#ifndef MSP_GENERATED_H
#define MSP_GENERATED_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#include "all_enums.h"
#include "all_defines.h"

#if defined(_MSC_VER)
  #define MSP_PACKED
  #pragma pack(push, 1)
#else
  #define MSP_PACKED __attribute__((packed))
#endif

#ifdef __cplusplus
extern "C" {
#endif

// ------- MSP command IDs -------
typedef enum {
    MSP_API_VERSION = 1,
    MSP_FC_VARIANT = 2,
    MSP_FC_VERSION = 3,
    MSP_BOARD_INFO = 4,
    MSP_BUILD_INFO = 5,
    MSP_INAV_PID = 6,
    MSP_SET_INAV_PID = 7,
    MSP_NAME = 10,
    MSP_SET_NAME = 11,
    MSP_NAV_POSHOLD = 12,
    MSP_SET_NAV_POSHOLD = 13,
    MSP_CALIBRATION_DATA = 14,
    MSP_SET_CALIBRATION_DATA = 15,
    MSP_POSITION_ESTIMATION_CONFIG = 16,
    MSP_SET_POSITION_ESTIMATION_CONFIG = 17,
    MSP_WP_MISSION_LOAD = 18,
    MSP_WP_MISSION_SAVE = 19,
    MSP_WP_GETINFO = 20,
    MSP_RTH_AND_LAND_CONFIG = 21,
    MSP_SET_RTH_AND_LAND_CONFIG = 22,
    MSP_FW_CONFIG = 23,
    MSP_SET_FW_CONFIG = 24,
    MSP_MODE_RANGES = 34,
    MSP_SET_MODE_RANGE = 35,
    MSP_FEATURE = 36,
    MSP_SET_FEATURE = 37,
    MSP_BOARD_ALIGNMENT = 38,
    MSP_SET_BOARD_ALIGNMENT = 39,
    MSP_CURRENT_METER_CONFIG = 40,
    MSP_SET_CURRENT_METER_CONFIG = 41,
    MSP_MIXER = 42,
    MSP_SET_MIXER = 43,
    MSP_RX_CONFIG = 44,
    MSP_SET_RX_CONFIG = 45,
    MSP_LED_COLORS = 46,
    MSP_SET_LED_COLORS = 47,
    MSP_LED_STRIP_CONFIG = 48,
    MSP_SET_LED_STRIP_CONFIG = 49,
    MSP_RSSI_CONFIG = 50,
    MSP_SET_RSSI_CONFIG = 51,
    MSP_ADJUSTMENT_RANGES = 52,
    MSP_SET_ADJUSTMENT_RANGE = 53,
    MSP_CF_SERIAL_CONFIG = 54,
    MSP_SET_CF_SERIAL_CONFIG = 55,
    MSP_VOLTAGE_METER_CONFIG = 56,
    MSP_SET_VOLTAGE_METER_CONFIG = 57,
    MSP_SONAR_ALTITUDE = 58,
    MSP_RX_MAP = 64,
    MSP_SET_RX_MAP = 65,
    MSP_REBOOT = 68,
    MSP_DATAFLASH_SUMMARY = 70,
    MSP_DATAFLASH_READ = 71,
    MSP_DATAFLASH_ERASE = 72,
    MSP_LOOP_TIME = 73,
    MSP_SET_LOOP_TIME = 74,
    MSP_FAILSAFE_CONFIG = 75,
    MSP_SET_FAILSAFE_CONFIG = 76,
    MSP_SDCARD_SUMMARY = 79,
    MSP_BLACKBOX_CONFIG = 80,
    MSP_SET_BLACKBOX_CONFIG = 81,
    MSP_TRANSPONDER_CONFIG = 82,
    MSP_SET_TRANSPONDER_CONFIG = 83,
    MSP_OSD_CONFIG = 84,
    MSP_SET_OSD_CONFIG = 85,
    MSP_OSD_CHAR_READ = 86,
    MSP_OSD_CHAR_WRITE = 87,
    MSP_VTX_CONFIG = 88,
    MSP_SET_VTX_CONFIG = 89,
    MSP_ADVANCED_CONFIG = 90,
    MSP_SET_ADVANCED_CONFIG = 91,
    MSP_FILTER_CONFIG = 92,
    MSP_SET_FILTER_CONFIG = 93,
    MSP_PID_ADVANCED = 94,
    MSP_SET_PID_ADVANCED = 95,
    MSP_SENSOR_CONFIG = 96,
    MSP_SET_SENSOR_CONFIG = 97,
    MSP_SPECIAL_PARAMETERS = 98,
    MSP_SET_SPECIAL_PARAMETERS = 99,
    MSP_IDENT = 100,
    MSP_STATUS = 101,
    MSP_RAW_IMU = 102,
    MSP_SERVO = 103,
    MSP_MOTOR = 104,
    MSP_RC = 105,
    MSP_RAW_GPS = 106,
    MSP_COMP_GPS = 107,
    MSP_ATTITUDE = 108,
    MSP_ALTITUDE = 109,
    MSP_ANALOG = 110,
    MSP_RC_TUNING = 111,
    MSP_ACTIVEBOXES = 113,
    MSP_MISC = 114,
    MSP_BOXNAMES = 116,
    MSP_PIDNAMES = 117,
    MSP_WP = 118,
    MSP_BOXIDS = 119,
    MSP_SERVO_CONFIGURATIONS = 120,
    MSP_NAV_STATUS = 121,
    MSP_NAV_CONFIG = 122,
    MSP_3D = 124,
    MSP_RC_DEADBAND = 125,
    MSP_SENSOR_ALIGNMENT = 126,
    MSP_LED_STRIP_MODECOLOR = 127,
    MSP_BATTERY_STATE = 130,
    MSP_VTXTABLE_BAND = 137,
    MSP_VTXTABLE_POWERLEVEL = 138,
    MSP_STATUS_EX = 150,
    MSP_SENSOR_STATUS = 151,
    MSP_UID = 160,
    MSP_GPSSVINFO = 164,
    MSP_GPSSTATISTICS = 166,
    MSP_SET_TX_INFO = 186,
    MSP_TX_INFO = 187,
    MSP_SET_RAW_RC = 200,
    MSP_SET_RAW_GPS = 201,
    MSP_SET_BOX = 203,
    MSP_SET_RC_TUNING = 204,
    MSP_ACC_CALIBRATION = 205,
    MSP_MAG_CALIBRATION = 206,
    MSP_SET_MISC = 207,
    MSP_RESET_CONF = 208,
    MSP_SET_WP = 209,
    MSP_SELECT_SETTING = 210,
    MSP_SET_HEAD = 211,
    MSP_SET_SERVO_CONFIGURATION = 212,
    MSP_SET_MOTOR = 214,
    MSP_SET_NAV_CONFIG = 215,
    MSP_SET_3D = 217,
    MSP_SET_RC_DEADBAND = 218,
    MSP_SET_RESET_CURR_PID = 219,
    MSP_SET_SENSOR_ALIGNMENT = 220,
    MSP_SET_LED_STRIP_MODECOLOR = 221,
    MSP_SET_ACC_TRIM = 239,
    MSP_ACC_TRIM = 240,
    MSP_SERVO_MIX_RULES = 241,
    MSP_SET_SERVO_MIX_RULE = 242,
    MSP_SET_PASSTHROUGH = 245,
    MSP_RTC = 246,
    MSP_SET_RTC = 247,
    MSP_EEPROM_WRITE = 250,
    MSP_DEBUGMSG = 253,
    MSP_DEBUG = 254,
    MSP_V2_FRAME = 255,
    MSP2_COMMON_TZ = 4097,
    MSP2_COMMON_SET_TZ = 4098,
    MSP2_COMMON_SETTING = 4099,
    MSP2_COMMON_SET_SETTING = 4100,
    MSP2_COMMON_MOTOR_MIXER = 4101,
    MSP2_COMMON_SET_MOTOR_MIXER = 4102,
    MSP2_COMMON_SETTING_INFO = 4103,
    MSP2_COMMON_PG_LIST = 4104,
    MSP2_COMMON_SERIAL_CONFIG = 4105,
    MSP2_COMMON_SET_SERIAL_CONFIG = 4106,
    MSP2_COMMON_SET_RADAR_POS = 4107,
    MSP2_COMMON_SET_RADAR_ITD = 4108,
    MSP2_COMMON_SET_MSP_RC_LINK_STATS = 4109,
    MSP2_COMMON_SET_MSP_RC_INFO = 4110,
    MSP2_SENSOR_RANGEFINDER = 7937,
    MSP2_SENSOR_OPTIC_FLOW = 7938,
    MSP2_SENSOR_GPS = 7939,
    MSP2_SENSOR_COMPASS = 7940,
    MSP2_SENSOR_BAROMETER = 7941,
    MSP2_SENSOR_AIRSPEED = 7942,
    MSP2_SENSOR_HEADTRACKER = 7943,
    MSP2_INAV_STATUS = 8192,
    MSP2_INAV_OPTICAL_FLOW = 8193,
    MSP2_INAV_ANALOG = 8194,
    MSP2_INAV_MISC = 8195,
    MSP2_INAV_SET_MISC = 8196,
    MSP2_INAV_BATTERY_CONFIG = 8197,
    MSP2_INAV_SET_BATTERY_CONFIG = 8198,
    MSP2_INAV_RATE_PROFILE = 8199,
    MSP2_INAV_SET_RATE_PROFILE = 8200,
    MSP2_INAV_AIR_SPEED = 8201,
    MSP2_INAV_OUTPUT_MAPPING = 8202,
    MSP2_INAV_MC_BRAKING = 8203,
    MSP2_INAV_SET_MC_BRAKING = 8204,
    MSP2_INAV_OUTPUT_MAPPING_EXT = 8205,
    MSP2_INAV_TIMER_OUTPUT_MODE = 8206,
    MSP2_INAV_SET_TIMER_OUTPUT_MODE = 8207,
    MSP2_INAV_MIXER = 8208,
    MSP2_INAV_SET_MIXER = 8209,
    MSP2_INAV_OSD_LAYOUTS = 8210,
    MSP2_INAV_OSD_SET_LAYOUT_ITEM = 8211,
    MSP2_INAV_OSD_ALARMS = 8212,
    MSP2_INAV_OSD_SET_ALARMS = 8213,
    MSP2_INAV_OSD_PREFERENCES = 8214,
    MSP2_INAV_OSD_SET_PREFERENCES = 8215,
    MSP2_INAV_SELECT_BATTERY_PROFILE = 8216,
    MSP2_INAV_DEBUG = 8217,
    MSP2_BLACKBOX_CONFIG = 8218,
    MSP2_SET_BLACKBOX_CONFIG = 8219,
    MSP2_INAV_TEMP_SENSOR_CONFIG = 8220,
    MSP2_INAV_SET_TEMP_SENSOR_CONFIG = 8221,
    MSP2_INAV_TEMPERATURES = 8222,
    MSP_SIMULATOR = 8223,
    MSP2_INAV_SERVO_MIXER = 8224,
    MSP2_INAV_SET_SERVO_MIXER = 8225,
    MSP2_INAV_LOGIC_CONDITIONS = 8226,
    MSP2_INAV_SET_LOGIC_CONDITIONS = 8227,
    MSP2_INAV_GLOBAL_FUNCTIONS = 8228,
    MSP2_INAV_SET_GLOBAL_FUNCTIONS = 8229,
    MSP2_INAV_LOGIC_CONDITIONS_STATUS = 8230,
    MSP2_INAV_GVAR_STATUS = 8231,
    MSP2_INAV_PROGRAMMING_PID = 8232,
    MSP2_INAV_SET_PROGRAMMING_PID = 8233,
    MSP2_INAV_PROGRAMMING_PID_STATUS = 8234,
    MSP2_PID = 8240,
    MSP2_SET_PID = 8241,
    MSP2_INAV_OPFLOW_CALIBRATION = 8242,
    MSP2_INAV_FWUPDT_PREPARE = 8243,
    MSP2_INAV_FWUPDT_STORE = 8244,
    MSP2_INAV_FWUPDT_EXEC = 8245,
    MSP2_INAV_FWUPDT_ROLLBACK_PREPARE = 8246,
    MSP2_INAV_FWUPDT_ROLLBACK_EXEC = 8247,
    MSP2_INAV_SAFEHOME = 8248,
    MSP2_INAV_SET_SAFEHOME = 8249,
    MSP2_INAV_MISC2 = 8250,
    MSP2_INAV_LOGIC_CONDITIONS_SINGLE = 8251,
    MSP2_INAV_ESC_RPM = 8256,
    MSP2_INAV_ESC_TELEM = 8257,
    MSP2_INAV_LED_STRIP_CONFIG_EX = 8264,
    MSP2_INAV_SET_LED_STRIP_CONFIG_EX = 8265,
    MSP2_INAV_FW_APPROACH = 8266,
    MSP2_INAV_SET_FW_APPROACH = 8267,
    MSP2_INAV_GPS_UBLOX_COMMAND = 8272,
    MSP2_INAV_RATE_DYNAMICS = 8288,
    MSP2_INAV_SET_RATE_DYNAMICS = 8289,
    MSP2_INAV_EZ_TUNE = 8304,
    MSP2_INAV_EZ_TUNE_SET = 8305,
    MSP2_INAV_SELECT_MIXER_PROFILE = 8320,
    MSP2_ADSB_VEHICLE_LIST = 8336,
    MSP2_INAV_CUSTOM_OSD_ELEMENTS = 8448,
    MSP2_INAV_CUSTOM_OSD_ELEMENT = 8449,
    MSP2_INAV_SET_CUSTOM_OSD_ELEMENTS = 8450,
    MSP2_INAV_OUTPUT_MAPPING_EXT2 = 8461,
    MSP2_INAV_SERVO_CONFIG = 8704,
    MSP2_INAV_SET_SERVO_CONFIG = 8705,
    MSP2_INAV_GEOZONE = 8720,
    MSP2_INAV_SET_GEOZONE = 8721,
    MSP2_INAV_GEOZONE_VERTEX = 8722,
    MSP2_INAV_SET_GEOZONE_VERTEX = 8723,
    MSP2_BETAFLIGHT_BIND = 12288,
} msp_command_id;

// ------- MSP command metadata -------
#define MSP_API_VERSION_HEX 0x1
#define MSP_API_VERSION_ID 1
#define MSP_API_VERSION_MSPV 1
#define MSP_API_VERSION_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_FC_VARIANT_HEX 0x2
#define MSP_FC_VARIANT_ID 2
#define MSP_FC_VARIANT_MSPV 1
#define MSP_FC_VARIANT_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_FC_VERSION_HEX 0x3
#define MSP_FC_VERSION_ID 3
#define MSP_FC_VERSION_MSPV 1
#define MSP_FC_VERSION_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_BOARD_INFO_HEX 0x4
#define MSP_BOARD_INFO_ID 4
#define MSP_BOARD_INFO_MSPV 1
#define MSP_BOARD_INFO_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_BUILD_INFO_HEX 0x5
#define MSP_BUILD_INFO_ID 5
#define MSP_BUILD_INFO_MSPV 1
#define MSP_BUILD_INFO_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_INAV_PID_HEX 0x6
#define MSP_INAV_PID_ID 6
#define MSP_INAV_PID_MSPV 1
#define MSP_INAV_PID_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_INAV_PID_HEX 0x7
#define MSP_SET_INAV_PID_ID 7
#define MSP_SET_INAV_PID_MSPV 1
#define MSP_SET_INAV_PID_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_NAME_HEX 0xa
#define MSP_NAME_ID 10
#define MSP_NAME_MSPV 1
#define MSP_NAME_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_NAME_HEX 0xb
#define MSP_SET_NAME_ID 11
#define MSP_SET_NAME_MSPV 1
#define MSP_SET_NAME_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_NAV_POSHOLD_HEX 0xc
#define MSP_NAV_POSHOLD_ID 12
#define MSP_NAV_POSHOLD_MSPV 1
#define MSP_NAV_POSHOLD_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_NAV_POSHOLD_HEX 0xd
#define MSP_SET_NAV_POSHOLD_ID 13
#define MSP_SET_NAV_POSHOLD_MSPV 1
#define MSP_SET_NAV_POSHOLD_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_CALIBRATION_DATA_HEX 0xe
#define MSP_CALIBRATION_DATA_ID 14
#define MSP_CALIBRATION_DATA_MSPV 1
#define MSP_CALIBRATION_DATA_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_CALIBRATION_DATA_HEX 0xf
#define MSP_SET_CALIBRATION_DATA_ID 15
#define MSP_SET_CALIBRATION_DATA_MSPV 1
#define MSP_SET_CALIBRATION_DATA_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_POSITION_ESTIMATION_CONFIG_HEX 0x10
#define MSP_POSITION_ESTIMATION_CONFIG_ID 16
#define MSP_POSITION_ESTIMATION_CONFIG_MSPV 1
#define MSP_POSITION_ESTIMATION_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_POSITION_ESTIMATION_CONFIG_HEX 0x11
#define MSP_SET_POSITION_ESTIMATION_CONFIG_ID 17
#define MSP_SET_POSITION_ESTIMATION_CONFIG_MSPV 1
#define MSP_SET_POSITION_ESTIMATION_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_WP_MISSION_LOAD_HEX 0x12
#define MSP_WP_MISSION_LOAD_ID 18
#define MSP_WP_MISSION_LOAD_MSPV 1
#define MSP_WP_MISSION_LOAD_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_WP_MISSION_SAVE_HEX 0x13
#define MSP_WP_MISSION_SAVE_ID 19
#define MSP_WP_MISSION_SAVE_MSPV 1
#define MSP_WP_MISSION_SAVE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_WP_GETINFO_HEX 0x14
#define MSP_WP_GETINFO_ID 20
#define MSP_WP_GETINFO_MSPV 1
#define MSP_WP_GETINFO_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RTH_AND_LAND_CONFIG_HEX 0x15
#define MSP_RTH_AND_LAND_CONFIG_ID 21
#define MSP_RTH_AND_LAND_CONFIG_MSPV 1
#define MSP_RTH_AND_LAND_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RTH_AND_LAND_CONFIG_HEX 0x16
#define MSP_SET_RTH_AND_LAND_CONFIG_ID 22
#define MSP_SET_RTH_AND_LAND_CONFIG_MSPV 1
#define MSP_SET_RTH_AND_LAND_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_FW_CONFIG_HEX 0x17
#define MSP_FW_CONFIG_ID 23
#define MSP_FW_CONFIG_MSPV 1
#define MSP_FW_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_FW_CONFIG_HEX 0x18
#define MSP_SET_FW_CONFIG_ID 24
#define MSP_SET_FW_CONFIG_MSPV 1
#define MSP_SET_FW_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_MODE_RANGES_HEX 0x22
#define MSP_MODE_RANGES_ID 34
#define MSP_MODE_RANGES_MSPV 1
#define MSP_MODE_RANGES_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_MODE_RANGE_HEX 0x23
#define MSP_SET_MODE_RANGE_ID 35
#define MSP_SET_MODE_RANGE_MSPV 1
#define MSP_SET_MODE_RANGE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_FEATURE_HEX 0x24
#define MSP_FEATURE_ID 36
#define MSP_FEATURE_MSPV 1
#define MSP_FEATURE_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_FEATURE_HEX 0x25
#define MSP_SET_FEATURE_ID 37
#define MSP_SET_FEATURE_MSPV 1
#define MSP_SET_FEATURE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_BOARD_ALIGNMENT_HEX 0x26
#define MSP_BOARD_ALIGNMENT_ID 38
#define MSP_BOARD_ALIGNMENT_MSPV 1
#define MSP_BOARD_ALIGNMENT_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_BOARD_ALIGNMENT_HEX 0x27
#define MSP_SET_BOARD_ALIGNMENT_ID 39
#define MSP_SET_BOARD_ALIGNMENT_MSPV 1
#define MSP_SET_BOARD_ALIGNMENT_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_CURRENT_METER_CONFIG_HEX 0x28
#define MSP_CURRENT_METER_CONFIG_ID 40
#define MSP_CURRENT_METER_CONFIG_MSPV 1
#define MSP_CURRENT_METER_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_CURRENT_METER_CONFIG_HEX 0x29
#define MSP_SET_CURRENT_METER_CONFIG_ID 41
#define MSP_SET_CURRENT_METER_CONFIG_MSPV 1
#define MSP_SET_CURRENT_METER_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_MIXER_HEX 0x2a
#define MSP_MIXER_ID 42
#define MSP_MIXER_MSPV 1
#define MSP_MIXER_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_MIXER_HEX 0x2b
#define MSP_SET_MIXER_ID 43
#define MSP_SET_MIXER_MSPV 1
#define MSP_SET_MIXER_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RX_CONFIG_HEX 0x2c
#define MSP_RX_CONFIG_ID 44
#define MSP_RX_CONFIG_MSPV 1
#define MSP_RX_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RX_CONFIG_HEX 0x2d
#define MSP_SET_RX_CONFIG_ID 45
#define MSP_SET_RX_CONFIG_MSPV 1
#define MSP_SET_RX_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_LED_COLORS_HEX 0x2e
#define MSP_LED_COLORS_ID 46
#define MSP_LED_COLORS_MSPV 1
#define MSP_LED_COLORS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_LED_COLORS_HEX 0x2f
#define MSP_SET_LED_COLORS_ID 47
#define MSP_SET_LED_COLORS_MSPV 1
#define MSP_SET_LED_COLORS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_LED_STRIP_CONFIG_HEX 0x30
#define MSP_LED_STRIP_CONFIG_ID 48
#define MSP_LED_STRIP_CONFIG_MSPV 1
#define MSP_LED_STRIP_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_LED_STRIP_CONFIG_HEX 0x31
#define MSP_SET_LED_STRIP_CONFIG_ID 49
#define MSP_SET_LED_STRIP_CONFIG_MSPV 1
#define MSP_SET_LED_STRIP_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RSSI_CONFIG_HEX 0x32
#define MSP_RSSI_CONFIG_ID 50
#define MSP_RSSI_CONFIG_MSPV 1
#define MSP_RSSI_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RSSI_CONFIG_HEX 0x33
#define MSP_SET_RSSI_CONFIG_ID 51
#define MSP_SET_RSSI_CONFIG_MSPV 1
#define MSP_SET_RSSI_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_ADJUSTMENT_RANGES_HEX 0x34
#define MSP_ADJUSTMENT_RANGES_ID 52
#define MSP_ADJUSTMENT_RANGES_MSPV 1
#define MSP_ADJUSTMENT_RANGES_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_ADJUSTMENT_RANGE_HEX 0x35
#define MSP_SET_ADJUSTMENT_RANGE_ID 53
#define MSP_SET_ADJUSTMENT_RANGE_MSPV 1
#define MSP_SET_ADJUSTMENT_RANGE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_CF_SERIAL_CONFIG_HEX 0x36
#define MSP_CF_SERIAL_CONFIG_ID 54
#define MSP_CF_SERIAL_CONFIG_MSPV 1
#define MSP_CF_SERIAL_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_CF_SERIAL_CONFIG_HEX 0x37
#define MSP_SET_CF_SERIAL_CONFIG_ID 55
#define MSP_SET_CF_SERIAL_CONFIG_MSPV 1
#define MSP_SET_CF_SERIAL_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_VOLTAGE_METER_CONFIG_HEX 0x38
#define MSP_VOLTAGE_METER_CONFIG_ID 56
#define MSP_VOLTAGE_METER_CONFIG_MSPV 1
#define MSP_VOLTAGE_METER_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_VOLTAGE_METER_CONFIG_HEX 0x39
#define MSP_SET_VOLTAGE_METER_CONFIG_ID 57
#define MSP_SET_VOLTAGE_METER_CONFIG_MSPV 1
#define MSP_SET_VOLTAGE_METER_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SONAR_ALTITUDE_HEX 0x3a
#define MSP_SONAR_ALTITUDE_ID 58
#define MSP_SONAR_ALTITUDE_MSPV 1
#define MSP_SONAR_ALTITUDE_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RX_MAP_HEX 0x40
#define MSP_RX_MAP_ID 64
#define MSP_RX_MAP_MSPV 1
#define MSP_RX_MAP_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RX_MAP_HEX 0x41
#define MSP_SET_RX_MAP_ID 65
#define MSP_SET_RX_MAP_MSPV 1
#define MSP_SET_RX_MAP_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_REBOOT_HEX 0x44
#define MSP_REBOOT_ID 68
#define MSP_REBOOT_MSPV 1
#define MSP_REBOOT_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_DATAFLASH_SUMMARY_HEX 0x46
#define MSP_DATAFLASH_SUMMARY_ID 70
#define MSP_DATAFLASH_SUMMARY_MSPV 1
#define MSP_DATAFLASH_SUMMARY_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_DATAFLASH_READ_HEX 0x47
#define MSP_DATAFLASH_READ_ID 71
#define MSP_DATAFLASH_READ_MSPV 1
#define MSP_DATAFLASH_READ_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_DATAFLASH_ERASE_HEX 0x48
#define MSP_DATAFLASH_ERASE_ID 72
#define MSP_DATAFLASH_ERASE_MSPV 1
#define MSP_DATAFLASH_ERASE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_LOOP_TIME_HEX 0x49
#define MSP_LOOP_TIME_ID 73
#define MSP_LOOP_TIME_MSPV 1
#define MSP_LOOP_TIME_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_LOOP_TIME_HEX 0x4a
#define MSP_SET_LOOP_TIME_ID 74
#define MSP_SET_LOOP_TIME_MSPV 1
#define MSP_SET_LOOP_TIME_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_FAILSAFE_CONFIG_HEX 0x4b
#define MSP_FAILSAFE_CONFIG_ID 75
#define MSP_FAILSAFE_CONFIG_MSPV 1
#define MSP_FAILSAFE_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_FAILSAFE_CONFIG_HEX 0x4c
#define MSP_SET_FAILSAFE_CONFIG_ID 76
#define MSP_SET_FAILSAFE_CONFIG_MSPV 1
#define MSP_SET_FAILSAFE_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SDCARD_SUMMARY_HEX 0x4f
#define MSP_SDCARD_SUMMARY_ID 79
#define MSP_SDCARD_SUMMARY_MSPV 1
#define MSP_SDCARD_SUMMARY_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_BLACKBOX_CONFIG_HEX 0x50
#define MSP_BLACKBOX_CONFIG_ID 80
#define MSP_BLACKBOX_CONFIG_MSPV 1
#define MSP_BLACKBOX_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_BLACKBOX_CONFIG_HEX 0x51
#define MSP_SET_BLACKBOX_CONFIG_ID 81
#define MSP_SET_BLACKBOX_CONFIG_MSPV 1
#define MSP_SET_BLACKBOX_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_TRANSPONDER_CONFIG_HEX 0x52
#define MSP_TRANSPONDER_CONFIG_ID 82
#define MSP_TRANSPONDER_CONFIG_MSPV 1
#define MSP_TRANSPONDER_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_TRANSPONDER_CONFIG_HEX 0x53
#define MSP_SET_TRANSPONDER_CONFIG_ID 83
#define MSP_SET_TRANSPONDER_CONFIG_MSPV 1
#define MSP_SET_TRANSPONDER_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_OSD_CONFIG_HEX 0x54
#define MSP_OSD_CONFIG_ID 84
#define MSP_OSD_CONFIG_MSPV 1
#define MSP_OSD_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_OSD_CONFIG_HEX 0x55
#define MSP_SET_OSD_CONFIG_ID 85
#define MSP_SET_OSD_CONFIG_MSPV 1
#define MSP_SET_OSD_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_OSD_CHAR_READ_HEX 0x56
#define MSP_OSD_CHAR_READ_ID 86
#define MSP_OSD_CHAR_READ_MSPV 1
#define MSP_OSD_CHAR_READ_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_OSD_CHAR_WRITE_HEX 0x57
#define MSP_OSD_CHAR_WRITE_ID 87
#define MSP_OSD_CHAR_WRITE_MSPV 1
#define MSP_OSD_CHAR_WRITE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_VTX_CONFIG_HEX 0x58
#define MSP_VTX_CONFIG_ID 88
#define MSP_VTX_CONFIG_MSPV 1
#define MSP_VTX_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_VTX_CONFIG_HEX 0x59
#define MSP_SET_VTX_CONFIG_ID 89
#define MSP_SET_VTX_CONFIG_MSPV 1
#define MSP_SET_VTX_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_ADVANCED_CONFIG_HEX 0x5a
#define MSP_ADVANCED_CONFIG_ID 90
#define MSP_ADVANCED_CONFIG_MSPV 1
#define MSP_ADVANCED_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_ADVANCED_CONFIG_HEX 0x5b
#define MSP_SET_ADVANCED_CONFIG_ID 91
#define MSP_SET_ADVANCED_CONFIG_MSPV 1
#define MSP_SET_ADVANCED_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_FILTER_CONFIG_HEX 0x5c
#define MSP_FILTER_CONFIG_ID 92
#define MSP_FILTER_CONFIG_MSPV 1
#define MSP_FILTER_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_FILTER_CONFIG_HEX 0x5d
#define MSP_SET_FILTER_CONFIG_ID 93
#define MSP_SET_FILTER_CONFIG_MSPV 1
#define MSP_SET_FILTER_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_PID_ADVANCED_HEX 0x5e
#define MSP_PID_ADVANCED_ID 94
#define MSP_PID_ADVANCED_MSPV 1
#define MSP_PID_ADVANCED_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_PID_ADVANCED_HEX 0x5f
#define MSP_SET_PID_ADVANCED_ID 95
#define MSP_SET_PID_ADVANCED_MSPV 1
#define MSP_SET_PID_ADVANCED_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SENSOR_CONFIG_HEX 0x60
#define MSP_SENSOR_CONFIG_ID 96
#define MSP_SENSOR_CONFIG_MSPV 1
#define MSP_SENSOR_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_SENSOR_CONFIG_HEX 0x61
#define MSP_SET_SENSOR_CONFIG_ID 97
#define MSP_SET_SENSOR_CONFIG_MSPV 1
#define MSP_SET_SENSOR_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SPECIAL_PARAMETERS_HEX 0x62
#define MSP_SPECIAL_PARAMETERS_ID 98
#define MSP_SPECIAL_PARAMETERS_MSPV 1
#define MSP_SPECIAL_PARAMETERS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_SPECIAL_PARAMETERS_HEX 0x63
#define MSP_SET_SPECIAL_PARAMETERS_ID 99
#define MSP_SET_SPECIAL_PARAMETERS_MSPV 1
#define MSP_SET_SPECIAL_PARAMETERS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_IDENT_HEX 0x64
#define MSP_IDENT_ID 100
#define MSP_IDENT_MSPV 1
#define MSP_IDENT_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_STATUS_HEX 0x65
#define MSP_STATUS_ID 101
#define MSP_STATUS_MSPV 1
#define MSP_STATUS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RAW_IMU_HEX 0x66
#define MSP_RAW_IMU_ID 102
#define MSP_RAW_IMU_MSPV 1
#define MSP_RAW_IMU_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SERVO_HEX 0x67
#define MSP_SERVO_ID 103
#define MSP_SERVO_MSPV 1
#define MSP_SERVO_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_MOTOR_HEX 0x68
#define MSP_MOTOR_ID 104
#define MSP_MOTOR_MSPV 1
#define MSP_MOTOR_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RC_HEX 0x69
#define MSP_RC_ID 105
#define MSP_RC_MSPV 1
#define MSP_RC_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RAW_GPS_HEX 0x6a
#define MSP_RAW_GPS_ID 106
#define MSP_RAW_GPS_MSPV 1
#define MSP_RAW_GPS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_COMP_GPS_HEX 0x6b
#define MSP_COMP_GPS_ID 107
#define MSP_COMP_GPS_MSPV 1
#define MSP_COMP_GPS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_ATTITUDE_HEX 0x6c
#define MSP_ATTITUDE_ID 108
#define MSP_ATTITUDE_MSPV 1
#define MSP_ATTITUDE_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_ALTITUDE_HEX 0x6d
#define MSP_ALTITUDE_ID 109
#define MSP_ALTITUDE_MSPV 1
#define MSP_ALTITUDE_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_ANALOG_HEX 0x6e
#define MSP_ANALOG_ID 110
#define MSP_ANALOG_MSPV 1
#define MSP_ANALOG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RC_TUNING_HEX 0x6f
#define MSP_RC_TUNING_ID 111
#define MSP_RC_TUNING_MSPV 1
#define MSP_RC_TUNING_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_ACTIVEBOXES_HEX 0x71
#define MSP_ACTIVEBOXES_ID 113
#define MSP_ACTIVEBOXES_MSPV 1
#define MSP_ACTIVEBOXES_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_MISC_HEX 0x72
#define MSP_MISC_ID 114
#define MSP_MISC_MSPV 1
#define MSP_MISC_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_BOXNAMES_HEX 0x74
#define MSP_BOXNAMES_ID 116
#define MSP_BOXNAMES_MSPV 1
#define MSP_BOXNAMES_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_PIDNAMES_HEX 0x75
#define MSP_PIDNAMES_ID 117
#define MSP_PIDNAMES_MSPV 1
#define MSP_PIDNAMES_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_WP_HEX 0x76
#define MSP_WP_ID 118
#define MSP_WP_MSPV 1
#define MSP_WP_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_BOXIDS_HEX 0x77
#define MSP_BOXIDS_ID 119
#define MSP_BOXIDS_MSPV 1
#define MSP_BOXIDS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SERVO_CONFIGURATIONS_HEX 0x78
#define MSP_SERVO_CONFIGURATIONS_ID 120
#define MSP_SERVO_CONFIGURATIONS_MSPV 1
#define MSP_SERVO_CONFIGURATIONS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_NAV_STATUS_HEX 0x79
#define MSP_NAV_STATUS_ID 121
#define MSP_NAV_STATUS_MSPV 1
#define MSP_NAV_STATUS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_NAV_CONFIG_HEX 0x7a
#define MSP_NAV_CONFIG_ID 122
#define MSP_NAV_CONFIG_MSPV 1

#define MSP_3D_HEX 0x7c
#define MSP_3D_ID 124
#define MSP_3D_MSPV 1
#define MSP_3D_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RC_DEADBAND_HEX 0x7d
#define MSP_RC_DEADBAND_ID 125
#define MSP_RC_DEADBAND_MSPV 1
#define MSP_RC_DEADBAND_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SENSOR_ALIGNMENT_HEX 0x7e
#define MSP_SENSOR_ALIGNMENT_ID 126
#define MSP_SENSOR_ALIGNMENT_MSPV 1
#define MSP_SENSOR_ALIGNMENT_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_LED_STRIP_MODECOLOR_HEX 0x7f
#define MSP_LED_STRIP_MODECOLOR_ID 127
#define MSP_LED_STRIP_MODECOLOR_MSPV 1
#define MSP_LED_STRIP_MODECOLOR_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_BATTERY_STATE_HEX 0x82
#define MSP_BATTERY_STATE_ID 130
#define MSP_BATTERY_STATE_MSPV 1
#define MSP_BATTERY_STATE_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_VTXTABLE_BAND_HEX 0x89
#define MSP_VTXTABLE_BAND_ID 137
#define MSP_VTXTABLE_BAND_MSPV 1
#define MSP_VTXTABLE_BAND_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_VTXTABLE_POWERLEVEL_HEX 0x8a
#define MSP_VTXTABLE_POWERLEVEL_ID 138
#define MSP_VTXTABLE_POWERLEVEL_MSPV 1
#define MSP_VTXTABLE_POWERLEVEL_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_STATUS_EX_HEX 0x96
#define MSP_STATUS_EX_ID 150
#define MSP_STATUS_EX_MSPV 1
#define MSP_STATUS_EX_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SENSOR_STATUS_HEX 0x97
#define MSP_SENSOR_STATUS_ID 151
#define MSP_SENSOR_STATUS_MSPV 1
#define MSP_SENSOR_STATUS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_UID_HEX 0xa0
#define MSP_UID_ID 160
#define MSP_UID_MSPV 1
#define MSP_UID_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_GPSSVINFO_HEX 0xa4
#define MSP_GPSSVINFO_ID 164
#define MSP_GPSSVINFO_MSPV 1
#define MSP_GPSSVINFO_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_GPSSTATISTICS_HEX 0xa6
#define MSP_GPSSTATISTICS_ID 166
#define MSP_GPSSTATISTICS_MSPV 1
#define MSP_GPSSTATISTICS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_TX_INFO_HEX 0xba
#define MSP_SET_TX_INFO_ID 186
#define MSP_SET_TX_INFO_MSPV 1
#define MSP_SET_TX_INFO_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_TX_INFO_HEX 0xbb
#define MSP_TX_INFO_ID 187
#define MSP_TX_INFO_MSPV 1
#define MSP_TX_INFO_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RAW_RC_HEX 0xc8
#define MSP_SET_RAW_RC_ID 200
#define MSP_SET_RAW_RC_MSPV 1
#define MSP_SET_RAW_RC_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RAW_GPS_HEX 0xc9
#define MSP_SET_RAW_GPS_ID 201
#define MSP_SET_RAW_GPS_MSPV 1
#define MSP_SET_RAW_GPS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_BOX_HEX 0xcb
#define MSP_SET_BOX_ID 203
#define MSP_SET_BOX_MSPV 1
#define MSP_SET_BOX_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RC_TUNING_HEX 0xcc
#define MSP_SET_RC_TUNING_ID 204
#define MSP_SET_RC_TUNING_MSPV 1
#define MSP_SET_RC_TUNING_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_ACC_CALIBRATION_HEX 0xcd
#define MSP_ACC_CALIBRATION_ID 205
#define MSP_ACC_CALIBRATION_MSPV 1
#define MSP_ACC_CALIBRATION_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_MAG_CALIBRATION_HEX 0xce
#define MSP_MAG_CALIBRATION_ID 206
#define MSP_MAG_CALIBRATION_MSPV 1
#define MSP_MAG_CALIBRATION_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_MISC_HEX 0xcf
#define MSP_SET_MISC_ID 207
#define MSP_SET_MISC_MSPV 1
#define MSP_SET_MISC_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RESET_CONF_HEX 0xd0
#define MSP_RESET_CONF_ID 208
#define MSP_RESET_CONF_MSPV 1
#define MSP_RESET_CONF_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_WP_HEX 0xd1
#define MSP_SET_WP_ID 209
#define MSP_SET_WP_MSPV 1
#define MSP_SET_WP_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SELECT_SETTING_HEX 0xd2
#define MSP_SELECT_SETTING_ID 210
#define MSP_SELECT_SETTING_MSPV 1
#define MSP_SELECT_SETTING_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_HEAD_HEX 0xd3
#define MSP_SET_HEAD_ID 211
#define MSP_SET_HEAD_MSPV 1
#define MSP_SET_HEAD_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_SERVO_CONFIGURATION_HEX 0xd4
#define MSP_SET_SERVO_CONFIGURATION_ID 212
#define MSP_SET_SERVO_CONFIGURATION_MSPV 1
#define MSP_SET_SERVO_CONFIGURATION_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_MOTOR_HEX 0xd6
#define MSP_SET_MOTOR_ID 214
#define MSP_SET_MOTOR_MSPV 1
#define MSP_SET_MOTOR_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_NAV_CONFIG_HEX 0xd7
#define MSP_SET_NAV_CONFIG_ID 215
#define MSP_SET_NAV_CONFIG_MSPV 1

#define MSP_SET_3D_HEX 0xd9
#define MSP_SET_3D_ID 217
#define MSP_SET_3D_MSPV 1
#define MSP_SET_3D_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RC_DEADBAND_HEX 0xda
#define MSP_SET_RC_DEADBAND_ID 218
#define MSP_SET_RC_DEADBAND_MSPV 1
#define MSP_SET_RC_DEADBAND_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RESET_CURR_PID_HEX 0xdb
#define MSP_SET_RESET_CURR_PID_ID 219
#define MSP_SET_RESET_CURR_PID_MSPV 1
#define MSP_SET_RESET_CURR_PID_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_SENSOR_ALIGNMENT_HEX 0xdc
#define MSP_SET_SENSOR_ALIGNMENT_ID 220
#define MSP_SET_SENSOR_ALIGNMENT_MSPV 1
#define MSP_SET_SENSOR_ALIGNMENT_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_LED_STRIP_MODECOLOR_HEX 0xdd
#define MSP_SET_LED_STRIP_MODECOLOR_ID 221
#define MSP_SET_LED_STRIP_MODECOLOR_MSPV 1
#define MSP_SET_LED_STRIP_MODECOLOR_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_ACC_TRIM_HEX 0xef
#define MSP_SET_ACC_TRIM_ID 239
#define MSP_SET_ACC_TRIM_MSPV 1
#define MSP_SET_ACC_TRIM_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_ACC_TRIM_HEX 0xf0
#define MSP_ACC_TRIM_ID 240
#define MSP_ACC_TRIM_MSPV 1
#define MSP_ACC_TRIM_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SERVO_MIX_RULES_HEX 0xf1
#define MSP_SERVO_MIX_RULES_ID 241
#define MSP_SERVO_MIX_RULES_MSPV 1
#define MSP_SERVO_MIX_RULES_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_SERVO_MIX_RULE_HEX 0xf2
#define MSP_SET_SERVO_MIX_RULE_ID 242
#define MSP_SET_SERVO_MIX_RULE_MSPV 1
#define MSP_SET_SERVO_MIX_RULE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_PASSTHROUGH_HEX 0xf5
#define MSP_SET_PASSTHROUGH_ID 245
#define MSP_SET_PASSTHROUGH_MSPV 1
#define MSP_SET_PASSTHROUGH_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_RTC_HEX 0xf6
#define MSP_RTC_ID 246
#define MSP_RTC_MSPV 1
#define MSP_RTC_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SET_RTC_HEX 0xf7
#define MSP_SET_RTC_ID 247
#define MSP_SET_RTC_MSPV 1
#define MSP_SET_RTC_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_EEPROM_WRITE_HEX 0xfa
#define MSP_EEPROM_WRITE_ID 250
#define MSP_EEPROM_WRITE_MSPV 1
#define MSP_EEPROM_WRITE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_DEBUGMSG_HEX 0xfd
#define MSP_DEBUGMSG_ID 253
#define MSP_DEBUGMSG_MSPV 1
#define MSP_DEBUGMSG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_DEBUG_HEX 0xfe
#define MSP_DEBUG_ID 254
#define MSP_DEBUG_MSPV 1
#define MSP_DEBUG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_V2_FRAME_HEX 0xff
#define MSP_V2_FRAME_ID 255
#define MSP_V2_FRAME_MSPV 1
#define MSP_V2_FRAME_DIRECTION -1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_TZ_HEX 0x1001
#define MSP2_COMMON_TZ_ID 4097
#define MSP2_COMMON_TZ_MSPV 2
#define MSP2_COMMON_TZ_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SET_TZ_HEX 0x1002
#define MSP2_COMMON_SET_TZ_ID 4098
#define MSP2_COMMON_SET_TZ_MSPV 2
#define MSP2_COMMON_SET_TZ_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SETTING_HEX 0x1003
#define MSP2_COMMON_SETTING_ID 4099
#define MSP2_COMMON_SETTING_MSPV 2
#define MSP2_COMMON_SETTING_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SET_SETTING_HEX 0x1004
#define MSP2_COMMON_SET_SETTING_ID 4100
#define MSP2_COMMON_SET_SETTING_MSPV 2
#define MSP2_COMMON_SET_SETTING_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_MOTOR_MIXER_HEX 0x1005
#define MSP2_COMMON_MOTOR_MIXER_ID 4101
#define MSP2_COMMON_MOTOR_MIXER_MSPV 2
#define MSP2_COMMON_MOTOR_MIXER_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SET_MOTOR_MIXER_HEX 0x1006
#define MSP2_COMMON_SET_MOTOR_MIXER_ID 4102
#define MSP2_COMMON_SET_MOTOR_MIXER_MSPV 2
#define MSP2_COMMON_SET_MOTOR_MIXER_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SETTING_INFO_HEX 0x1007
#define MSP2_COMMON_SETTING_INFO_ID 4103
#define MSP2_COMMON_SETTING_INFO_MSPV 2
#define MSP2_COMMON_SETTING_INFO_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_PG_LIST_HEX 0x1008
#define MSP2_COMMON_PG_LIST_ID 4104
#define MSP2_COMMON_PG_LIST_MSPV 2
#define MSP2_COMMON_PG_LIST_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SERIAL_CONFIG_HEX 0x1009
#define MSP2_COMMON_SERIAL_CONFIG_ID 4105
#define MSP2_COMMON_SERIAL_CONFIG_MSPV 2
#define MSP2_COMMON_SERIAL_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SET_SERIAL_CONFIG_HEX 0x100a
#define MSP2_COMMON_SET_SERIAL_CONFIG_ID 4106
#define MSP2_COMMON_SET_SERIAL_CONFIG_MSPV 2
#define MSP2_COMMON_SET_SERIAL_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SET_RADAR_POS_HEX 0x100b
#define MSP2_COMMON_SET_RADAR_POS_ID 4107
#define MSP2_COMMON_SET_RADAR_POS_MSPV 2
#define MSP2_COMMON_SET_RADAR_POS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SET_RADAR_ITD_HEX 0x100c
#define MSP2_COMMON_SET_RADAR_ITD_ID 4108
#define MSP2_COMMON_SET_RADAR_ITD_MSPV 2
#define MSP2_COMMON_SET_RADAR_ITD_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SET_MSP_RC_LINK_STATS_HEX 0x100d
#define MSP2_COMMON_SET_MSP_RC_LINK_STATS_ID 4109
#define MSP2_COMMON_SET_MSP_RC_LINK_STATS_MSPV 2
#define MSP2_COMMON_SET_MSP_RC_LINK_STATS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_COMMON_SET_MSP_RC_INFO_HEX 0x100e
#define MSP2_COMMON_SET_MSP_RC_INFO_ID 4110
#define MSP2_COMMON_SET_MSP_RC_INFO_MSPV 2
#define MSP2_COMMON_SET_MSP_RC_INFO_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SENSOR_RANGEFINDER_HEX 0x1f01
#define MSP2_SENSOR_RANGEFINDER_ID 7937
#define MSP2_SENSOR_RANGEFINDER_MSPV 2
#define MSP2_SENSOR_RANGEFINDER_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SENSOR_OPTIC_FLOW_HEX 0x1f02
#define MSP2_SENSOR_OPTIC_FLOW_ID 7938
#define MSP2_SENSOR_OPTIC_FLOW_MSPV 2
#define MSP2_SENSOR_OPTIC_FLOW_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SENSOR_GPS_HEX 0x1f03
#define MSP2_SENSOR_GPS_ID 7939
#define MSP2_SENSOR_GPS_MSPV 2
#define MSP2_SENSOR_GPS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SENSOR_COMPASS_HEX 0x1f04
#define MSP2_SENSOR_COMPASS_ID 7940
#define MSP2_SENSOR_COMPASS_MSPV 2
#define MSP2_SENSOR_COMPASS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SENSOR_BAROMETER_HEX 0x1f05
#define MSP2_SENSOR_BAROMETER_ID 7941
#define MSP2_SENSOR_BAROMETER_MSPV 2
#define MSP2_SENSOR_BAROMETER_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SENSOR_AIRSPEED_HEX 0x1f06
#define MSP2_SENSOR_AIRSPEED_ID 7942
#define MSP2_SENSOR_AIRSPEED_MSPV 2
#define MSP2_SENSOR_AIRSPEED_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SENSOR_HEADTRACKER_HEX 0x1f07
#define MSP2_SENSOR_HEADTRACKER_ID 7943
#define MSP2_SENSOR_HEADTRACKER_MSPV 2
#define MSP2_SENSOR_HEADTRACKER_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_STATUS_HEX 0x2000
#define MSP2_INAV_STATUS_ID 8192
#define MSP2_INAV_STATUS_MSPV 2
#define MSP2_INAV_STATUS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OPTICAL_FLOW_HEX 0x2001
#define MSP2_INAV_OPTICAL_FLOW_ID 8193
#define MSP2_INAV_OPTICAL_FLOW_MSPV 2
#define MSP2_INAV_OPTICAL_FLOW_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_ANALOG_HEX 0x2002
#define MSP2_INAV_ANALOG_ID 8194
#define MSP2_INAV_ANALOG_MSPV 2
#define MSP2_INAV_ANALOG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_MISC_HEX 0x2003
#define MSP2_INAV_MISC_ID 8195
#define MSP2_INAV_MISC_MSPV 2
#define MSP2_INAV_MISC_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_MISC_HEX 0x2004
#define MSP2_INAV_SET_MISC_ID 8196
#define MSP2_INAV_SET_MISC_MSPV 2
#define MSP2_INAV_SET_MISC_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_BATTERY_CONFIG_HEX 0x2005
#define MSP2_INAV_BATTERY_CONFIG_ID 8197
#define MSP2_INAV_BATTERY_CONFIG_MSPV 2
#define MSP2_INAV_BATTERY_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_BATTERY_CONFIG_HEX 0x2006
#define MSP2_INAV_SET_BATTERY_CONFIG_ID 8198
#define MSP2_INAV_SET_BATTERY_CONFIG_MSPV 2
#define MSP2_INAV_SET_BATTERY_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_RATE_PROFILE_HEX 0x2007
#define MSP2_INAV_RATE_PROFILE_ID 8199
#define MSP2_INAV_RATE_PROFILE_MSPV 2
#define MSP2_INAV_RATE_PROFILE_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_RATE_PROFILE_HEX 0x2008
#define MSP2_INAV_SET_RATE_PROFILE_ID 8200
#define MSP2_INAV_SET_RATE_PROFILE_MSPV 2
#define MSP2_INAV_SET_RATE_PROFILE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_AIR_SPEED_HEX 0x2009
#define MSP2_INAV_AIR_SPEED_ID 8201
#define MSP2_INAV_AIR_SPEED_MSPV 2
#define MSP2_INAV_AIR_SPEED_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OUTPUT_MAPPING_HEX 0x200a
#define MSP2_INAV_OUTPUT_MAPPING_ID 8202
#define MSP2_INAV_OUTPUT_MAPPING_MSPV 2
#define MSP2_INAV_OUTPUT_MAPPING_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_MC_BRAKING_HEX 0x200b
#define MSP2_INAV_MC_BRAKING_ID 8203
#define MSP2_INAV_MC_BRAKING_MSPV 2
#define MSP2_INAV_MC_BRAKING_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_MC_BRAKING_HEX 0x200c
#define MSP2_INAV_SET_MC_BRAKING_ID 8204
#define MSP2_INAV_SET_MC_BRAKING_MSPV 2
#define MSP2_INAV_SET_MC_BRAKING_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OUTPUT_MAPPING_EXT_HEX 0x200d
#define MSP2_INAV_OUTPUT_MAPPING_EXT_ID 8205
#define MSP2_INAV_OUTPUT_MAPPING_EXT_MSPV 2
#define MSP2_INAV_OUTPUT_MAPPING_EXT_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_TIMER_OUTPUT_MODE_HEX 0x200e
#define MSP2_INAV_TIMER_OUTPUT_MODE_ID 8206
#define MSP2_INAV_TIMER_OUTPUT_MODE_MSPV 2
#define MSP2_INAV_TIMER_OUTPUT_MODE_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_TIMER_OUTPUT_MODE_HEX 0x200f
#define MSP2_INAV_SET_TIMER_OUTPUT_MODE_ID 8207
#define MSP2_INAV_SET_TIMER_OUTPUT_MODE_MSPV 2
#define MSP2_INAV_SET_TIMER_OUTPUT_MODE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_MIXER_HEX 0x2010
#define MSP2_INAV_MIXER_ID 8208
#define MSP2_INAV_MIXER_MSPV 2
#define MSP2_INAV_MIXER_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_MIXER_HEX 0x2011
#define MSP2_INAV_SET_MIXER_ID 8209
#define MSP2_INAV_SET_MIXER_MSPV 2
#define MSP2_INAV_SET_MIXER_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OSD_LAYOUTS_HEX 0x2012
#define MSP2_INAV_OSD_LAYOUTS_ID 8210
#define MSP2_INAV_OSD_LAYOUTS_MSPV 2
#define MSP2_INAV_OSD_LAYOUTS_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OSD_SET_LAYOUT_ITEM_HEX 0x2013
#define MSP2_INAV_OSD_SET_LAYOUT_ITEM_ID 8211
#define MSP2_INAV_OSD_SET_LAYOUT_ITEM_MSPV 2
#define MSP2_INAV_OSD_SET_LAYOUT_ITEM_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OSD_ALARMS_HEX 0x2014
#define MSP2_INAV_OSD_ALARMS_ID 8212
#define MSP2_INAV_OSD_ALARMS_MSPV 2
#define MSP2_INAV_OSD_ALARMS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OSD_SET_ALARMS_HEX 0x2015
#define MSP2_INAV_OSD_SET_ALARMS_ID 8213
#define MSP2_INAV_OSD_SET_ALARMS_MSPV 2
#define MSP2_INAV_OSD_SET_ALARMS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OSD_PREFERENCES_HEX 0x2016
#define MSP2_INAV_OSD_PREFERENCES_ID 8214
#define MSP2_INAV_OSD_PREFERENCES_MSPV 2
#define MSP2_INAV_OSD_PREFERENCES_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OSD_SET_PREFERENCES_HEX 0x2017
#define MSP2_INAV_OSD_SET_PREFERENCES_ID 8215
#define MSP2_INAV_OSD_SET_PREFERENCES_MSPV 2
#define MSP2_INAV_OSD_SET_PREFERENCES_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SELECT_BATTERY_PROFILE_HEX 0x2018
#define MSP2_INAV_SELECT_BATTERY_PROFILE_ID 8216
#define MSP2_INAV_SELECT_BATTERY_PROFILE_MSPV 2
#define MSP2_INAV_SELECT_BATTERY_PROFILE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_DEBUG_HEX 0x2019
#define MSP2_INAV_DEBUG_ID 8217
#define MSP2_INAV_DEBUG_MSPV 2
#define MSP2_INAV_DEBUG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_BLACKBOX_CONFIG_HEX 0x201a
#define MSP2_BLACKBOX_CONFIG_ID 8218
#define MSP2_BLACKBOX_CONFIG_MSPV 2
#define MSP2_BLACKBOX_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SET_BLACKBOX_CONFIG_HEX 0x201b
#define MSP2_SET_BLACKBOX_CONFIG_ID 8219
#define MSP2_SET_BLACKBOX_CONFIG_MSPV 2
#define MSP2_SET_BLACKBOX_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_TEMP_SENSOR_CONFIG_HEX 0x201c
#define MSP2_INAV_TEMP_SENSOR_CONFIG_ID 8220
#define MSP2_INAV_TEMP_SENSOR_CONFIG_MSPV 2
#define MSP2_INAV_TEMP_SENSOR_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_TEMP_SENSOR_CONFIG_HEX 0x201d
#define MSP2_INAV_SET_TEMP_SENSOR_CONFIG_ID 8221
#define MSP2_INAV_SET_TEMP_SENSOR_CONFIG_MSPV 2
#define MSP2_INAV_SET_TEMP_SENSOR_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_TEMPERATURES_HEX 0x201e
#define MSP2_INAV_TEMPERATURES_ID 8222
#define MSP2_INAV_TEMPERATURES_MSPV 2
#define MSP2_INAV_TEMPERATURES_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP_SIMULATOR_HEX 0x201f
#define MSP_SIMULATOR_ID 8223
#define MSP_SIMULATOR_MSPV 2
#define MSP_SIMULATOR_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SERVO_MIXER_HEX 0x2020
#define MSP2_INAV_SERVO_MIXER_ID 8224
#define MSP2_INAV_SERVO_MIXER_MSPV 2
#define MSP2_INAV_SERVO_MIXER_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_SERVO_MIXER_HEX 0x2021
#define MSP2_INAV_SET_SERVO_MIXER_ID 8225
#define MSP2_INAV_SET_SERVO_MIXER_MSPV 2
#define MSP2_INAV_SET_SERVO_MIXER_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_LOGIC_CONDITIONS_HEX 0x2022
#define MSP2_INAV_LOGIC_CONDITIONS_ID 8226
#define MSP2_INAV_LOGIC_CONDITIONS_MSPV 2
#define MSP2_INAV_LOGIC_CONDITIONS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_LOGIC_CONDITIONS_HEX 0x2023
#define MSP2_INAV_SET_LOGIC_CONDITIONS_ID 8227
#define MSP2_INAV_SET_LOGIC_CONDITIONS_MSPV 2
#define MSP2_INAV_SET_LOGIC_CONDITIONS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_GLOBAL_FUNCTIONS_HEX 0x2024
#define MSP2_INAV_GLOBAL_FUNCTIONS_ID 8228
#define MSP2_INAV_GLOBAL_FUNCTIONS_MSPV 2

#define MSP2_INAV_SET_GLOBAL_FUNCTIONS_HEX 0x2025
#define MSP2_INAV_SET_GLOBAL_FUNCTIONS_ID 8229
#define MSP2_INAV_SET_GLOBAL_FUNCTIONS_MSPV 2

#define MSP2_INAV_LOGIC_CONDITIONS_STATUS_HEX 0x2026
#define MSP2_INAV_LOGIC_CONDITIONS_STATUS_ID 8230
#define MSP2_INAV_LOGIC_CONDITIONS_STATUS_MSPV 2
#define MSP2_INAV_LOGIC_CONDITIONS_STATUS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_GVAR_STATUS_HEX 0x2027
#define MSP2_INAV_GVAR_STATUS_ID 8231
#define MSP2_INAV_GVAR_STATUS_MSPV 2
#define MSP2_INAV_GVAR_STATUS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_PROGRAMMING_PID_HEX 0x2028
#define MSP2_INAV_PROGRAMMING_PID_ID 8232
#define MSP2_INAV_PROGRAMMING_PID_MSPV 2
#define MSP2_INAV_PROGRAMMING_PID_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_PROGRAMMING_PID_HEX 0x2029
#define MSP2_INAV_SET_PROGRAMMING_PID_ID 8233
#define MSP2_INAV_SET_PROGRAMMING_PID_MSPV 2
#define MSP2_INAV_SET_PROGRAMMING_PID_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_PROGRAMMING_PID_STATUS_HEX 0x202a
#define MSP2_INAV_PROGRAMMING_PID_STATUS_ID 8234
#define MSP2_INAV_PROGRAMMING_PID_STATUS_MSPV 2
#define MSP2_INAV_PROGRAMMING_PID_STATUS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_PID_HEX 0x2030
#define MSP2_PID_ID 8240
#define MSP2_PID_MSPV 2
#define MSP2_PID_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_SET_PID_HEX 0x2031
#define MSP2_SET_PID_ID 8241
#define MSP2_SET_PID_MSPV 2
#define MSP2_SET_PID_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OPFLOW_CALIBRATION_HEX 0x2032
#define MSP2_INAV_OPFLOW_CALIBRATION_ID 8242
#define MSP2_INAV_OPFLOW_CALIBRATION_MSPV 2
#define MSP2_INAV_OPFLOW_CALIBRATION_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_FWUPDT_PREPARE_HEX 0x2033
#define MSP2_INAV_FWUPDT_PREPARE_ID 8243
#define MSP2_INAV_FWUPDT_PREPARE_MSPV 2
#define MSP2_INAV_FWUPDT_PREPARE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_FWUPDT_STORE_HEX 0x2034
#define MSP2_INAV_FWUPDT_STORE_ID 8244
#define MSP2_INAV_FWUPDT_STORE_MSPV 2
#define MSP2_INAV_FWUPDT_STORE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_FWUPDT_EXEC_HEX 0x2035
#define MSP2_INAV_FWUPDT_EXEC_ID 8245
#define MSP2_INAV_FWUPDT_EXEC_MSPV 2
#define MSP2_INAV_FWUPDT_EXEC_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_FWUPDT_ROLLBACK_PREPARE_HEX 0x2036
#define MSP2_INAV_FWUPDT_ROLLBACK_PREPARE_ID 8246
#define MSP2_INAV_FWUPDT_ROLLBACK_PREPARE_MSPV 2
#define MSP2_INAV_FWUPDT_ROLLBACK_PREPARE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_FWUPDT_ROLLBACK_EXEC_HEX 0x2037
#define MSP2_INAV_FWUPDT_ROLLBACK_EXEC_ID 8247
#define MSP2_INAV_FWUPDT_ROLLBACK_EXEC_MSPV 2
#define MSP2_INAV_FWUPDT_ROLLBACK_EXEC_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SAFEHOME_HEX 0x2038
#define MSP2_INAV_SAFEHOME_ID 8248
#define MSP2_INAV_SAFEHOME_MSPV 2
#define MSP2_INAV_SAFEHOME_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_SAFEHOME_HEX 0x2039
#define MSP2_INAV_SET_SAFEHOME_ID 8249
#define MSP2_INAV_SET_SAFEHOME_MSPV 2
#define MSP2_INAV_SET_SAFEHOME_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_MISC2_HEX 0x203a
#define MSP2_INAV_MISC2_ID 8250
#define MSP2_INAV_MISC2_MSPV 2
#define MSP2_INAV_MISC2_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_LOGIC_CONDITIONS_SINGLE_HEX 0x203b
#define MSP2_INAV_LOGIC_CONDITIONS_SINGLE_ID 8251
#define MSP2_INAV_LOGIC_CONDITIONS_SINGLE_MSPV 2
#define MSP2_INAV_LOGIC_CONDITIONS_SINGLE_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_ESC_RPM_HEX 0x2040
#define MSP2_INAV_ESC_RPM_ID 8256
#define MSP2_INAV_ESC_RPM_MSPV 2
#define MSP2_INAV_ESC_RPM_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_ESC_TELEM_HEX 0x2041
#define MSP2_INAV_ESC_TELEM_ID 8257
#define MSP2_INAV_ESC_TELEM_MSPV 2
#define MSP2_INAV_ESC_TELEM_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_LED_STRIP_CONFIG_EX_HEX 0x2048
#define MSP2_INAV_LED_STRIP_CONFIG_EX_ID 8264
#define MSP2_INAV_LED_STRIP_CONFIG_EX_MSPV 2
#define MSP2_INAV_LED_STRIP_CONFIG_EX_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_LED_STRIP_CONFIG_EX_HEX 0x2049
#define MSP2_INAV_SET_LED_STRIP_CONFIG_EX_ID 8265
#define MSP2_INAV_SET_LED_STRIP_CONFIG_EX_MSPV 2
#define MSP2_INAV_SET_LED_STRIP_CONFIG_EX_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_FW_APPROACH_HEX 0x204a
#define MSP2_INAV_FW_APPROACH_ID 8266
#define MSP2_INAV_FW_APPROACH_MSPV 2
#define MSP2_INAV_FW_APPROACH_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_FW_APPROACH_HEX 0x204b
#define MSP2_INAV_SET_FW_APPROACH_ID 8267
#define MSP2_INAV_SET_FW_APPROACH_MSPV 2
#define MSP2_INAV_SET_FW_APPROACH_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_GPS_UBLOX_COMMAND_HEX 0x2050
#define MSP2_INAV_GPS_UBLOX_COMMAND_ID 8272
#define MSP2_INAV_GPS_UBLOX_COMMAND_MSPV 2
#define MSP2_INAV_GPS_UBLOX_COMMAND_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_RATE_DYNAMICS_HEX 0x2060
#define MSP2_INAV_RATE_DYNAMICS_ID 8288
#define MSP2_INAV_RATE_DYNAMICS_MSPV 2
#define MSP2_INAV_RATE_DYNAMICS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_RATE_DYNAMICS_HEX 0x2061
#define MSP2_INAV_SET_RATE_DYNAMICS_ID 8289
#define MSP2_INAV_SET_RATE_DYNAMICS_MSPV 2
#define MSP2_INAV_SET_RATE_DYNAMICS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_EZ_TUNE_HEX 0x2070
#define MSP2_INAV_EZ_TUNE_ID 8304
#define MSP2_INAV_EZ_TUNE_MSPV 2
#define MSP2_INAV_EZ_TUNE_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_EZ_TUNE_SET_HEX 0x2071
#define MSP2_INAV_EZ_TUNE_SET_ID 8305
#define MSP2_INAV_EZ_TUNE_SET_MSPV 2
#define MSP2_INAV_EZ_TUNE_SET_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SELECT_MIXER_PROFILE_HEX 0x2080
#define MSP2_INAV_SELECT_MIXER_PROFILE_ID 8320
#define MSP2_INAV_SELECT_MIXER_PROFILE_MSPV 2
#define MSP2_INAV_SELECT_MIXER_PROFILE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_ADSB_VEHICLE_LIST_HEX 0x2090
#define MSP2_ADSB_VEHICLE_LIST_ID 8336
#define MSP2_ADSB_VEHICLE_LIST_MSPV 2
#define MSP2_ADSB_VEHICLE_LIST_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_CUSTOM_OSD_ELEMENTS_HEX 0x2100
#define MSP2_INAV_CUSTOM_OSD_ELEMENTS_ID 8448
#define MSP2_INAV_CUSTOM_OSD_ELEMENTS_MSPV 2
#define MSP2_INAV_CUSTOM_OSD_ELEMENTS_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_CUSTOM_OSD_ELEMENT_HEX 0x2101
#define MSP2_INAV_CUSTOM_OSD_ELEMENT_ID 8449
#define MSP2_INAV_CUSTOM_OSD_ELEMENT_MSPV 2
#define MSP2_INAV_CUSTOM_OSD_ELEMENT_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_CUSTOM_OSD_ELEMENTS_HEX 0x2102
#define MSP2_INAV_SET_CUSTOM_OSD_ELEMENTS_ID 8450
#define MSP2_INAV_SET_CUSTOM_OSD_ELEMENTS_MSPV 2
#define MSP2_INAV_SET_CUSTOM_OSD_ELEMENTS_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_OUTPUT_MAPPING_EXT2_HEX 0x210d
#define MSP2_INAV_OUTPUT_MAPPING_EXT2_ID 8461
#define MSP2_INAV_OUTPUT_MAPPING_EXT2_MSPV 2
#define MSP2_INAV_OUTPUT_MAPPING_EXT2_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SERVO_CONFIG_HEX 0x2200
#define MSP2_INAV_SERVO_CONFIG_ID 8704
#define MSP2_INAV_SERVO_CONFIG_MSPV 2
#define MSP2_INAV_SERVO_CONFIG_DIRECTION 1  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_SERVO_CONFIG_HEX 0x2201
#define MSP2_INAV_SET_SERVO_CONFIG_ID 8705
#define MSP2_INAV_SET_SERVO_CONFIG_MSPV 2
#define MSP2_INAV_SET_SERVO_CONFIG_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_GEOZONE_HEX 0x2210
#define MSP2_INAV_GEOZONE_ID 8720
#define MSP2_INAV_GEOZONE_MSPV 2
#define MSP2_INAV_GEOZONE_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_GEOZONE_HEX 0x2211
#define MSP2_INAV_SET_GEOZONE_ID 8721
#define MSP2_INAV_SET_GEOZONE_MSPV 2
#define MSP2_INAV_SET_GEOZONE_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_GEOZONE_VERTEX_HEX 0x2212
#define MSP2_INAV_GEOZONE_VERTEX_ID 8722
#define MSP2_INAV_GEOZONE_VERTEX_MSPV 2
#define MSP2_INAV_GEOZONE_VERTEX_DIRECTION 2  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_INAV_SET_GEOZONE_VERTEX_HEX 0x2213
#define MSP2_INAV_SET_GEOZONE_VERTEX_ID 8723
#define MSP2_INAV_SET_GEOZONE_VERTEX_MSPV 2
#define MSP2_INAV_SET_GEOZONE_VERTEX_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)

#define MSP2_BETAFLIGHT_BIND_HEX 0x3000
#define MSP2_BETAFLIGHT_BIND_ID 12288
#define MSP2_BETAFLIGHT_BIND_MSPV 2
#define MSP2_BETAFLIGHT_BIND_DIRECTION 0  // 1=requests expecting reply, 0=write-only (as per JSON)


// ------- MSP message structs -------
// MSP_API_VERSION
// Provides the MSP protocol version and the INAV API version.
// Notes: Used by configurators to check compatibility.
// No request payload for MSP_API_VERSION.

typedef struct MSP_PACKED {
    uint8_t mspProtocolVersion; // MSP Protocol version (`MSP_PROTOCOL_VERSION`, typically 0).
    uint8_t apiVersionMajor; // INAV API Major version (`API_VERSION_MAJOR`).
    uint8_t apiVersionMinor; // INAV API Minor version (`API_VERSION_MINOR`).
} msp_MSP_API_VERSION_reply_t;

#define MSP_API_VERSION_REPLY_PAYLOAD_SIZE 3

// MSP_FC_VARIANT
// Identifies the flight controller firmware variant (e.g., INAV, Betaflight).
// Notes: See `FLIGHT_CONTROLLER_IDENTIFIER_LENGTH`.
// No request payload for MSP_FC_VARIANT.

typedef struct MSP_PACKED {
    char fcVariantIdentifier[4]; // 4-character identifier string (e.g., "INAV"). Defined by `flightControllerIdentifier`.
} msp_MSP_FC_VARIANT_reply_t;

#define MSP_FC_VARIANT_REPLY_PAYLOAD_SIZE 4

// MSP_FC_VERSION
// Provides the specific version number of the flight controller firmware.
// No request payload for MSP_FC_VERSION.

typedef struct MSP_PACKED {
    uint8_t fcVersionMajor; // Firmware Major version (`FC_VERSION_MAJOR`).
    uint8_t fcVersionMinor; // Firmware Minor version (`FC_VERSION_MINOR`).
    uint8_t fcVersionPatch; // Firmware Patch level (`FC_VERSION_PATCH_LEVEL`).
} msp_MSP_FC_VERSION_reply_t;

#define MSP_FC_VERSION_REPLY_PAYLOAD_SIZE 3

// MSP_BOARD_INFO
// Provides information about the specific hardware board and its capabilities.
// Notes: `BOARD_IDENTIFIER_LENGTH` is 4.
// No request payload for MSP_BOARD_INFO.

typedef struct MSP_PACKED {
    char boardIdentifier[4]; // 4-character UPPER CASE board identifier (`TARGET_BOARD_IDENTIFIER`).
    uint16_t hardwareRevision; // Hardware revision number. 0 if not detected (`USE_HARDWARE_REVISION_DETECTION`).
    uint8_t osdSupport; // OSD chip type: 0=None, 2=Onboard (`USE_OSD`). INAV does not support slave OSD (1).
    uint8_t commCapabilities; // Communication capabilities bitmask: Bit 0=VCP support (`USE_VCP`), Bit 1=SoftSerial support (`USE_SOFTSERIAL1`/`2`).
    uint8_t targetNameLength; // Length of the target name string that follows.
    char targetName[]; // Target name string (e.g., "MATEKF405"). Length given by previous field.
} msp_MSP_BOARD_INFO_reply_t;

// #define MSP_BOARD_INFO_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_BUILD_INFO
// Provides build date, time, and Git revision of the firmware.
// No request payload for MSP_BUILD_INFO.

typedef struct MSP_PACKED {
    char buildDate[11]; // Build date string (e.g., "Dec 31 2023"). `BUILD_DATE_LENGTH`.
    char buildTime[8]; // Build time string (e.g., "23:59:59"). `BUILD_TIME_LENGTH`.
    char gitRevision[7]; // Short Git revision string. `GIT_SHORT_REVISION_LENGTH`.
} msp_MSP_BUILD_INFO_reply_t;

#define MSP_BUILD_INFO_REPLY_PAYLOAD_SIZE 26

// MSP_INAV_PID
// Retrieves legacy INAV-specific PID controller related settings. Many fields are now obsolete or placeholders.
// Notes: Superseded by `MSP2_PID` for core PIDs and other specific messages for filter settings.
// No request payload for MSP_INAV_PID.

typedef struct MSP_PACKED {
    uint8_t legacyAsyncProcessing; // Legacy, unused. Always 0.
    uint16_t legacyAsyncValue1; // Legacy, unused. Always 0.
    uint16_t legacyAsyncValue2; // Legacy, unused. Always 0.
    uint8_t headingHoldRateLimit; // Max rate for heading hold P term (`pidProfile()->heading_hold_rate_limit`).
    uint8_t headingHoldLpfFreq; // Fixed LPF frequency for heading hold error (`HEADING_HOLD_ERROR_LPF_FREQ`).
    uint16_t legacyYawJumpLimit; // Legacy, unused. Always 0.
    uint8_t legacyGyroLpf; // Fixed value `GYRO_LPF_256HZ`.
    uint8_t accLpfHz; // Accelerometer LPF frequency (`accelerometerConfig()->acc_lpf_hz`).
    uint8_t reserved1; // Reserved. Always 0.
    uint8_t reserved2; // Reserved. Always 0.
    uint8_t reserved3; // Reserved. Always 0.
    uint8_t reserved4; // Reserved. Always 0.
} msp_MSP_INAV_PID_reply_t;

#define MSP_INAV_PID_REPLY_PAYLOAD_SIZE 15

// MSP_SET_INAV_PID
// Sets legacy INAV-specific PID controller related settings.
// Notes: Expects 15 bytes.
typedef struct MSP_PACKED {
    uint8_t legacyAsyncProcessing; // Legacy, ignored.
    uint16_t legacyAsyncValue1; // Legacy, ignored.
    uint16_t legacyAsyncValue2; // Legacy, ignored.
    uint8_t headingHoldRateLimit; // Sets `pidProfileMutable()->heading_hold_rate_limit`.
    uint8_t headingHoldLpfFreq; // Ignored (fixed value `HEADING_HOLD_ERROR_LPF_FREQ` used).
    uint16_t legacyYawJumpLimit; // Legacy, ignored.
    uint8_t legacyGyroLpf; // Ignored (was gyro LPF).
    uint8_t accLpfHz; // Sets `accelerometerConfigMutable()->acc_lpf_hz`.
    uint8_t reserved1; // Ignored.
    uint8_t reserved2; // Ignored.
    uint8_t reserved3; // Ignored.
    uint8_t reserved4; // Ignored.
} msp_MSP_SET_INAV_PID_request_t;

#define MSP_SET_INAV_PID_REQUEST_PAYLOAD_SIZE 15

// No reply payload for MSP_SET_INAV_PID.

// MSP_NAME
// Returns the user-defined craft name.
// No request payload for MSP_NAME.

typedef struct MSP_PACKED {
    char craftName[]; // The craft name string (`systemConfig()->craftName`). Null termination is *not* explicitly sent, the length is determined by the payload size.
} msp_MSP_NAME_reply_t;

// #define MSP_NAME_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_SET_NAME
// Sets the user-defined craft name.
// Notes: Maximum length is `MAX_NAME_LENGTH`.
typedef struct MSP_PACKED {
    char craftName[]; // The new craft name string. Automatically null-terminated by the FC.
} msp_MSP_SET_NAME_request_t;

// #define MSP_SET_NAME_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP_SET_NAME.

// MSP_NAV_POSHOLD
// Retrieves navigation position hold and general manual/auto flight parameters. Some parameters depend on the platform type (Multirotor vs Fixed Wing).
// No request payload for MSP_NAV_POSHOLD.

typedef struct MSP_PACKED {
    uint8_t userControlMode; // Navigation user control mode (`navConfig()->general.flags.user_control_mode`).
    uint16_t maxAutoSpeed; // Max speed in autonomous modes (`navConfig()->general.max_auto_speed`).
    uint16_t maxAutoClimbRate; // Max climb rate in autonomous modes (uses `fw.max_auto_climb_rate` or `mc.max_auto_climb_rate` based on platform).
    uint16_t maxManualSpeed; // Max speed in manual modes with GPS aiding (`navConfig()->general.max_manual_speed`).
    uint16_t maxManualClimbRate; // Max climb rate in manual modes with GPS aiding (uses `fw.max_manual_climb_rate` or `mc.max_manual_climb_rate`).
    uint8_t mcMaxBankAngle; // Max bank angle for multirotor position hold (`navConfig()->mc.max_bank_angle`).
    uint8_t mcAltHoldThrottleType; // Altitude Hold throttle control type (`navConfig()->mc.althold_throttle_type`).
    uint16_t mcHoverThrottle; // Multirotor hover throttle (`currentBatteryProfile->nav.mc.hover_throttle`).
} msp_MSP_NAV_POSHOLD_reply_t;

#define MSP_NAV_POSHOLD_REPLY_PAYLOAD_SIZE 13

// MSP_SET_NAV_POSHOLD
// Sets navigation position hold and general manual/auto flight parameters.
// Notes: Expects 13 bytes.
typedef struct MSP_PACKED {
    uint8_t userControlMode; // Sets `navConfigMutable()->general.flags.user_control_mode`.
    uint16_t maxAutoSpeed; // Sets `navConfigMutable()->general.max_auto_speed`.
    uint16_t maxAutoClimbRate; // Sets `fw.max_auto_climb_rate` or `mc.max_auto_climb_rate` based on current platform type.
    uint16_t maxManualSpeed; // Sets `navConfigMutable()->general.max_manual_speed`.
    uint16_t maxManualClimbRate; // Sets `fw.max_manual_climb_rate` or `mc.max_manual_climb_rate`.
    uint8_t mcMaxBankAngle; // Sets `navConfigMutable()->mc.max_bank_angle`.
    uint8_t mcAltHoldThrottleType; // Sets `navConfigMutable()->mc.althold_throttle_type`.
    uint16_t mcHoverThrottle; // Sets `currentBatteryProfileMutable->nav.mc.hover_throttle`.
} msp_MSP_SET_NAV_POSHOLD_request_t;

#define MSP_SET_NAV_POSHOLD_REQUEST_PAYLOAD_SIZE 13

// No reply payload for MSP_SET_NAV_POSHOLD.

// MSP_CALIBRATION_DATA
// Retrieves sensor calibration data (Accelerometer zero/gain, Magnetometer zero/gain, Optical Flow scale).
// Notes: Total size 27 bytes. Fields related to optional sensors are zero if the sensor is not used.
// No request payload for MSP_CALIBRATION_DATA.

typedef struct MSP_PACKED {
    uint8_t accCalibAxisFlags; // Flags indicating which axes of the accelerometer have been calibrated (`accGetCalibrationAxisFlags()`).
    uint16_t accZeroX; // Accelerometer zero offset for X-axis (`accelerometerConfig()->accZero.raw[X]`).
    uint16_t accZeroY; // Accelerometer zero offset for Y-axis (`accelerometerConfig()->accZero.raw[Y]`).
    uint16_t accZeroZ; // Accelerometer zero offset for Z-axis (`accelerometerConfig()->accZero.raw[Z]`).
    uint16_t accGainX; // Accelerometer gain/scale for X-axis (`accelerometerConfig()->accGain.raw[X]`).
    uint16_t accGainY; // Accelerometer gain/scale for Y-axis (`accelerometerConfig()->accGain.raw[Y]`).
    uint16_t accGainZ; // Accelerometer gain/scale for Z-axis (`accelerometerConfig()->accGain.raw[Z]`).
    uint16_t magZeroX; // Magnetometer zero offset for X-axis (`compassConfig()->magZero.raw[X]`). 0 if `USE_MAG` disabled.
    uint16_t magZeroY; // Magnetometer zero offset for Y-axis (`compassConfig()->magZero.raw[Y]`). 0 if `USE_MAG` disabled.
    uint16_t magZeroZ; // Magnetometer zero offset for Z-axis (`compassConfig()->magZero.raw[Z]`). 0 if `USE_MAG` disabled.
    uint16_t opflowScale; // Optical flow scale factor (`opticalFlowConfig()->opflow_scale * 256`). 0 if `USE_OPFLOW` disabled.
    uint16_t magGainX; // Magnetometer gain/scale for X-axis (`compassConfig()->magGain[X]`). 0 if `USE_MAG` disabled.
    uint16_t magGainY; // Magnetometer gain/scale for Y-axis (`compassConfig()->magGain[Y]`). 0 if `USE_MAG` disabled.
    uint16_t magGainZ; // Magnetometer gain/scale for Z-axis (`compassConfig()->magGain[Z]`). 0 if `USE_MAG` disabled.
} msp_MSP_CALIBRATION_DATA_reply_t;

#define MSP_CALIBRATION_DATA_REPLY_PAYLOAD_SIZE 27

// MSP_SET_CALIBRATION_DATA
// Sets sensor calibration data.
// Notes: Expects 26 bytes. Ignores values for sensors not enabled by `USE_*` defines.
typedef struct MSP_PACKED {
    uint16_t accZeroX; // Sets `accelerometerConfigMutable()->accZero.raw[X]`.
    uint16_t accZeroY; // Sets `accelerometerConfigMutable()->accZero.raw[Y]`.
    uint16_t accZeroZ; // Sets `accelerometerConfigMutable()->accZero.raw[Z]`.
    uint16_t accGainX; // Sets `accelerometerConfigMutable()->accGain.raw[X]`.
    uint16_t accGainY; // Sets `accelerometerConfigMutable()->accGain.raw[Y]`.
    uint16_t accGainZ; // Sets `accelerometerConfigMutable()->accGain.raw[Z]`.
    uint16_t magZeroX; // Sets `compassConfigMutable()->magZero.raw[X]` (if `USE_MAG`).
    uint16_t magZeroY; // Sets `compassConfigMutable()->magZero.raw[Y]` (if `USE_MAG`).
    uint16_t magZeroZ; // Sets `compassConfigMutable()->magZero.raw[Z]` (if `USE_MAG`).
    uint16_t opflowScale; // Sets `opticalFlowConfigMutable()->opflow_scale = value / 256.0f` (if `USE_OPFLOW`).
    uint16_t magGainX; // Sets `compassConfigMutable()->magGain[X]` (if `USE_MAG`).
    uint16_t magGainY; // Sets `compassConfigMutable()->magGain[Y]` (if `USE_MAG`).
    uint16_t magGainZ; // Sets `compassConfigMutable()->magGain[Z]` (if `USE_MAG`).
} msp_MSP_SET_CALIBRATION_DATA_request_t;

#define MSP_SET_CALIBRATION_DATA_REQUEST_PAYLOAD_SIZE 26

// No reply payload for MSP_SET_CALIBRATION_DATA.

// MSP_POSITION_ESTIMATION_CONFIG
// Retrieves parameters related to the INAV position estimation fusion weights and GPS minimum satellite count.
// No request payload for MSP_POSITION_ESTIMATION_CONFIG.

typedef struct MSP_PACKED {
    uint16_t weightZBaroP; // Barometer Z position fusion weight (`positionEstimationConfig()->w_z_baro_p * 100`).
    uint16_t weightZGPSP; // GPS Z position fusion weight (`positionEstimationConfig()->w_z_gps_p * 100`).
    uint16_t weightZGPSV; // GPS Z velocity fusion weight (`positionEstimationConfig()->w_z_gps_v * 100`).
    uint16_t weightXYGPSP; // GPS XY position fusion weight (`positionEstimationConfig()->w_xy_gps_p * 100`).
    uint16_t weightXYGPSV; // GPS XY velocity fusion weight (`positionEstimationConfig()->w_xy_gps_v * 100`).
    uint8_t minSats; // Minimum satellites required for GPS use (`gpsConfigMutable()->gpsMinSats`).
    uint8_t useGPSVelNED; // Legacy flag, always 1 (GPS velocity is always used if available).
} msp_MSP_POSITION_ESTIMATION_CONFIG_reply_t;

#define MSP_POSITION_ESTIMATION_CONFIG_REPLY_PAYLOAD_SIZE 12

// MSP_SET_POSITION_ESTIMATION_CONFIG
// Sets parameters related to the INAV position estimation fusion weights and GPS minimum satellite count.
// Notes: Expects 12 bytes.
typedef struct MSP_PACKED {
    uint16_t weightZBaroP; // Sets `positionEstimationConfigMutable()->w_z_baro_p = value / 100.0f` (constrained 0.0-10.0).
    uint16_t weightZGPSP; // Sets `positionEstimationConfigMutable()->w_z_gps_p = value / 100.0f` (constrained 0.0-10.0).
    uint16_t weightZGPSV; // Sets `positionEstimationConfigMutable()->w_z_gps_v = value / 100.0f` (constrained 0.0-10.0).
    uint16_t weightXYGPSP; // Sets `positionEstimationConfigMutable()->w_xy_gps_p = value / 100.0f` (constrained 0.0-10.0).
    uint16_t weightXYGPSV; // Sets `positionEstimationConfigMutable()->w_xy_gps_v = value / 100.0f` (constrained 0.0-10.0).
    uint8_t minSats; // Sets `gpsConfigMutable()->gpsMinSats` (constrained 5-10).
    uint8_t useGPSVelNED; // Legacy flag, ignored.
} msp_MSP_SET_POSITION_ESTIMATION_CONFIG_request_t;

#define MSP_SET_POSITION_ESTIMATION_CONFIG_REQUEST_PAYLOAD_SIZE 12

// No reply payload for MSP_SET_POSITION_ESTIMATION_CONFIG.

// MSP_WP_MISSION_LOAD
// Commands the FC to load the waypoint mission stored in non-volatile memory (e.g., EEPROM or FlashFS) into the active mission buffer.
// Notes: Only functional if `NAV_NON_VOLATILE_WAYPOINT_STORAGE` is defined. Requires 1 byte payload. Returns error if loading fails.
typedef struct MSP_PACKED {
    uint8_t missionID; // Reserved for future use, currently ignored.
} msp_MSP_WP_MISSION_LOAD_request_t;

#define MSP_WP_MISSION_LOAD_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP_WP_MISSION_LOAD.

// MSP_WP_MISSION_SAVE
// Commands the FC to save the currently active waypoint mission from RAM to non-volatile memory (e.g., EEPROM or FlashFS).
// Notes: Only functional if `NAV_NON_VOLATILE_WAYPOINT_STORAGE` is defined. Requires 1 byte payload. Returns error if saving fails.
typedef struct MSP_PACKED {
    uint8_t missionID; // Reserved for future use, currently ignored.
} msp_MSP_WP_MISSION_SAVE_request_t;

#define MSP_WP_MISSION_SAVE_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP_WP_MISSION_SAVE.

// MSP_WP_GETINFO
// Retrieves information about the waypoint mission capabilities and the status of the currently loaded mission.
// No request payload for MSP_WP_GETINFO.

typedef struct MSP_PACKED {
    uint8_t wpCapabilities; // Reserved for future waypoint capabilities flags. Currently always 0.
    uint8_t maxWaypoints; // Maximum number of waypoints supported (`NAV_MAX_WAYPOINTS`).
    uint8_t missionValid; // Boolean flag indicating if the current mission in RAM is valid (`isWaypointListValid()`).
    uint8_t waypointCount; // Number of waypoints currently defined in the mission (`getWaypointCount()`).
} msp_MSP_WP_GETINFO_reply_t;

#define MSP_WP_GETINFO_REPLY_PAYLOAD_SIZE 4

// MSP_RTH_AND_LAND_CONFIG
// Retrieves configuration parameters related to Return-to-Home (RTH) and automatic landing behaviors.
// No request payload for MSP_RTH_AND_LAND_CONFIG.

typedef struct MSP_PACKED {
    uint16_t minRthDistance; // Minimum distance from home required for RTH to engage (`navConfig()->general.min_rth_distance`).
    uint8_t rthClimbFirst; // Flag: Climb to RTH altitude before returning (`navConfig()->general.flags.rth_climb_first`).
    uint8_t rthClimbIgnoreEmerg; // Flag: Climb even in emergency RTH (`navConfig()->general.flags.rth_climb_ignore_emerg`).
    uint8_t rthTailFirst; // Flag: Multirotor returns tail-first (`navConfig()->general.flags.rth_tail_first`).
    uint8_t rthAllowLanding; // Flag: Allow automatic landing after RTH (`navConfig()->general.flags.rth_allow_landing`).
    uint8_t rthAltControlMode; // RTH altitude control mode (`navConfig()->general.flags.rth_alt_control_mode`).
    uint16_t rthAbortThreshold; // Stick input threshold to abort RTH (`navConfig()->general.rth_abort_threshold`).
    uint16_t rthAltitude; // Target RTH altitude (`navConfig()->general.rth_altitude`).
    uint16_t landMinAltVspd; // Landing vertical speed at minimum slowdown altitude (`navConfig()->general.land_minalt_vspd`).
    uint16_t landMaxAltVspd; // Landing vertical speed at maximum slowdown altitude (`navConfig()->general.land_maxalt_vspd`).
    uint16_t landSlowdownMinAlt; // Altitude below which `landMinAltVspd` applies (`navConfig()->general.land_slowdown_minalt`).
    uint16_t landSlowdownMaxAlt; // Altitude above which `landMaxAltVspd` applies (`navConfig()->general.land_slowdown_maxalt`).
    uint16_t emergDescentRate; // Vertical speed during emergency landing descent (`navConfig()->general.emerg_descent_rate`).
} msp_MSP_RTH_AND_LAND_CONFIG_reply_t;

#define MSP_RTH_AND_LAND_CONFIG_REPLY_PAYLOAD_SIZE 21

// MSP_SET_RTH_AND_LAND_CONFIG
// Sets configuration parameters related to Return-to-Home (RTH) and automatic landing behaviors.
// Notes: Expects 21 bytes.
typedef struct MSP_PACKED {
    uint16_t minRthDistance; // Sets `navConfigMutable()->general.min_rth_distance`.
    uint8_t rthClimbFirst; // Sets `navConfigMutable()->general.flags.rth_climb_first`.
    uint8_t rthClimbIgnoreEmerg; // Sets `navConfigMutable()->general.flags.rth_climb_ignore_emerg`.
    uint8_t rthTailFirst; // Sets `navConfigMutable()->general.flags.rth_tail_first`.
    uint8_t rthAllowLanding; // Sets `navConfigMutable()->general.flags.rth_allow_landing`.
    uint8_t rthAltControlMode; // Sets `navConfigMutable()->general.flags.rth_alt_control_mode`.
    uint16_t rthAbortThreshold; // Sets `navConfigMutable()->general.rth_abort_threshold`.
    uint16_t rthAltitude; // Sets `navConfigMutable()->general.rth_altitude`.
    uint16_t landMinAltVspd; // Sets `navConfigMutable()->general.land_minalt_vspd`.
    uint16_t landMaxAltVspd; // Sets `navConfigMutable()->general.land_maxalt_vspd`.
    uint16_t landSlowdownMinAlt; // Sets `navConfigMutable()->general.land_slowdown_minalt`.
    uint16_t landSlowdownMaxAlt; // Sets `navConfigMutable()->general.land_slowdown_maxalt`.
    uint16_t emergDescentRate; // Sets `navConfigMutable()->general.emerg_descent_rate`.
} msp_MSP_SET_RTH_AND_LAND_CONFIG_request_t;

#define MSP_SET_RTH_AND_LAND_CONFIG_REQUEST_PAYLOAD_SIZE 21

// No reply payload for MSP_SET_RTH_AND_LAND_CONFIG.

// MSP_FW_CONFIG
// Retrieves configuration parameters specific to Fixed Wing navigation.
// No request payload for MSP_FW_CONFIG.

typedef struct MSP_PACKED {
    uint16_t cruiseThrottle; // Cruise throttle level (`currentBatteryProfile->nav.fw.cruise_throttle`).
    uint16_t minThrottle; // Minimum throttle during autonomous flight (`currentBatteryProfile->nav.fw.min_throttle`).
    uint16_t maxThrottle; // Maximum throttle during autonomous flight (`currentBatteryProfile->nav.fw.max_throttle`).
    uint8_t maxBankAngle; // Maximum bank angle allowed (`navConfig()->fw.max_bank_angle`).
    uint8_t maxClimbAngle; // Maximum pitch angle during climb (`navConfig()->fw.max_climb_angle`).
    uint8_t maxDiveAngle; // Maximum negative pitch angle during descent (`navConfig()->fw.max_dive_angle`).
    uint8_t pitchToThrottle; // Pitch-to-throttle feed-forward ratio (`currentBatteryProfile->nav.fw.pitch_to_throttle`).
    uint16_t loiterRadius; // Default loiter radius (`navConfig()->fw.loiter_radius`).
} msp_MSP_FW_CONFIG_reply_t;

#define MSP_FW_CONFIG_REPLY_PAYLOAD_SIZE 12

// MSP_SET_FW_CONFIG
// Sets configuration parameters specific to Fixed Wing navigation.
// Notes: Expects 12 bytes.
typedef struct MSP_PACKED {
    uint16_t cruiseThrottle; // Sets `currentBatteryProfileMutable->nav.fw.cruise_throttle`.
    uint16_t minThrottle; // Sets `currentBatteryProfileMutable->nav.fw.min_throttle`.
    uint16_t maxThrottle; // Sets `currentBatteryProfileMutable->nav.fw.max_throttle`.
    uint8_t maxBankAngle; // Sets `navConfigMutable()->fw.max_bank_angle`.
    uint8_t maxClimbAngle; // Sets `navConfigMutable()->fw.max_climb_angle`.
    uint8_t maxDiveAngle; // Sets `navConfigMutable()->fw.max_dive_angle`.
    uint8_t pitchToThrottle; // Sets `currentBatteryProfileMutable->nav.fw.pitch_to_throttle`.
    uint16_t loiterRadius; // Sets `navConfigMutable()->fw.loiter_radius`.
} msp_MSP_SET_FW_CONFIG_request_t;

#define MSP_SET_FW_CONFIG_REQUEST_PAYLOAD_SIZE 12

// No reply payload for MSP_SET_FW_CONFIG.

// MSP_MODE_RANGES
// Returns all defined mode activation ranges (aux channel assignments for flight modes).
// Notes: The number of steps and mapping to PWM values depends on internal range calculations.
// No request payload for MSP_MODE_RANGES.

typedef struct MSP_PACKED {
    uint8_t modePermanentId; // Permanent ID of the flight mode (maps to `boxId` via `findBoxByActiveBoxId`). 0 if entry unused.
    uint8_t auxChannelIndex; // 0-based index of the AUX channel used for activation.
    uint8_t rangeStartStep; // Start step (corresponding to channel value range 900-2100 in steps of 50/25, depends on steps calculation).
    uint8_t rangeEndStep; // End step for the activation range.
} msp_MSP_MODE_RANGES_reply_t;

#define MSP_MODE_RANGES_REPLY_PAYLOAD_SIZE 4

// MSP_SET_MODE_RANGE
// Sets a single mode activation range by its index.
// Notes: Expects 5 bytes. Updates the mode configuration and recalculates used mode flags. Returns error if `rangeIndex` or `modePermanentId` is invalid.
typedef struct MSP_PACKED {
    uint8_t rangeIndex; // Index of the mode range to set (0 to `MAX_MODE_ACTIVATION_CONDITION_COUNT - 1`).
    uint8_t modePermanentId; // Permanent ID of the flight mode to assign.
    uint8_t auxChannelIndex; // 0-based index of the AUX channel.
    uint8_t rangeStartStep; // Start step for activation.
    uint8_t rangeEndStep; // End step for activation.
} msp_MSP_SET_MODE_RANGE_request_t;

#define MSP_SET_MODE_RANGE_REQUEST_PAYLOAD_SIZE 5

// No reply payload for MSP_SET_MODE_RANGE.

// MSP_FEATURE
// Returns a bitmask of enabled features.
// Notes: Feature bits are defined in `feature.h`.
// No request payload for MSP_FEATURE.

typedef struct MSP_PACKED {
    uint32_t featureMask; // Bitmask of active features (see `featureMask()`).
} msp_MSP_FEATURE_reply_t;

#define MSP_FEATURE_REPLY_PAYLOAD_SIZE 4

// MSP_SET_FEATURE
// Sets the enabled features using a bitmask. Clears all previous features first.
// Notes: Expects 4 bytes. Updates feature configuration and related settings (e.g., RSSI source).
typedef struct MSP_PACKED {
    uint32_t featureMask; // Bitmask of features to enable.
} msp_MSP_SET_FEATURE_request_t;

#define MSP_SET_FEATURE_REQUEST_PAYLOAD_SIZE 4

// No reply payload for MSP_SET_FEATURE.

// MSP_BOARD_ALIGNMENT
// Returns the sensor board alignment angles relative to the craft frame.
// No request payload for MSP_BOARD_ALIGNMENT.

typedef struct MSP_PACKED {
    uint16_t rollAlign; // Board alignment roll angle (`boardAlignment()->rollDeciDegrees`).
    uint16_t pitchAlign; // Board alignment pitch angle (`boardAlignment()->pitchDeciDegrees`).
    uint16_t yawAlign; // Board alignment yaw angle (`boardAlignment()->yawDeciDegrees`).
} msp_MSP_BOARD_ALIGNMENT_reply_t;

#define MSP_BOARD_ALIGNMENT_REPLY_PAYLOAD_SIZE 6

// MSP_SET_BOARD_ALIGNMENT
// Sets the sensor board alignment angles.
// Notes: Expects 6 bytes.
typedef struct MSP_PACKED {
    uint16_t rollAlign; // Sets `boardAlignmentMutable()->rollDeciDegrees`.
    uint16_t pitchAlign; // Sets `boardAlignmentMutable()->pitchDeciDegrees`.
    uint16_t yawAlign; // Sets `boardAlignmentMutable()->yawDeciDegrees`.
} msp_MSP_SET_BOARD_ALIGNMENT_request_t;

#define MSP_SET_BOARD_ALIGNMENT_REQUEST_PAYLOAD_SIZE 6

// No reply payload for MSP_SET_BOARD_ALIGNMENT.

// MSP_CURRENT_METER_CONFIG
// Retrieves the configuration for the current sensor.
// No request payload for MSP_CURRENT_METER_CONFIG.

typedef struct MSP_PACKED {
    uint16_t scale; // Current sensor scale factor (`batteryMetersConfig()->current.scale`). Units depend on sensor type.
    uint16_t offset; // Current sensor offset (`batteryMetersConfig()->current.offset`).
    uint8_t type; // Type of current sensor hardware (`batteryMetersConfig()->current.type`).
    uint16_t capacity; // Battery capacity (constrained 0-65535) (`currentBatteryProfile->capacity.value`). Note: This is legacy, use `MSP2_INAV_BATTERY_CONFIG` for full 32-bit capacity.
} msp_MSP_CURRENT_METER_CONFIG_reply_t;

#define MSP_CURRENT_METER_CONFIG_REPLY_PAYLOAD_SIZE 7

// MSP_SET_CURRENT_METER_CONFIG
// Sets the configuration for the current sensor.
// Notes: Expects 7 bytes.
typedef struct MSP_PACKED {
    uint16_t scale; // Sets `batteryMetersConfigMutable()->current.scale`.
    uint16_t offset; // Sets `batteryMetersConfigMutable()->current.offset`.
    uint8_t type; // Sets `batteryMetersConfigMutable()->current.type`.
    uint16_t capacity; // Sets `currentBatteryProfileMutable->capacity.value` (truncated to 16 bits).
} msp_MSP_SET_CURRENT_METER_CONFIG_request_t;

#define MSP_SET_CURRENT_METER_CONFIG_REQUEST_PAYLOAD_SIZE 7

// No reply payload for MSP_SET_CURRENT_METER_CONFIG.

// MSP_MIXER
// Retrieves the mixer type (Legacy, INAV always returns QuadX).
// Notes: This command is largely obsolete. Mixer configuration is handled differently in INAV (presets, custom mixes). See `MSP2_INAV_MIXER`.
// No request payload for MSP_MIXER.

typedef struct MSP_PACKED {
    uint8_t mixerMode; // Always 3 (QuadX) in INAV for compatibility.
} msp_MSP_MIXER_reply_t;

#define MSP_MIXER_REPLY_PAYLOAD_SIZE 1

// MSP_SET_MIXER
// Sets the mixer type (Legacy, ignored by INAV).
// Notes: Expects 1 byte. Calls `mixerUpdateStateFlags()` for potential side effects related to presets.
typedef struct MSP_PACKED {
    uint8_t mixerMode; // Mixer mode to set (ignored by INAV).
} msp_MSP_SET_MIXER_request_t;

#define MSP_SET_MIXER_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP_SET_MIXER.

// MSP_RX_CONFIG
// Retrieves receiver configuration settings. Some fields are Betaflight compatibility placeholders.
// No request payload for MSP_RX_CONFIG.

typedef struct MSP_PACKED {
    uint8_t serialRxProvider; // Serial RX provider type (`rxConfig()->serialrx_provider`).
    uint16_t maxCheck; // Upper channel value threshold for stick commands (`rxConfig()->maxcheck`).
    uint16_t midRc; // Center channel value (`PWM_RANGE_MIDDLE`, typically 1500).
    uint16_t minCheck; // Lower channel value threshold for stick commands (`rxConfig()->mincheck`).
    uint8_t spektrumSatBind; // Spektrum bind pulses (`rxConfig()->spektrum_sat_bind`). 0 if `USE_SPEKTRUM_BIND` disabled.
    uint16_t rxMinUsec; // Minimum expected pulse width (`rxConfig()->rx_min_usec`).
    uint16_t rxMaxUsec; // Maximum expected pulse width (`rxConfig()->rx_max_usec`).
    uint8_t bfCompatRcInterpolation; // BF compatibility. Always 0.
    uint8_t bfCompatRcInterpolationInt; // BF compatibility. Always 0.
    uint16_t bfCompatAirModeThreshold; // BF compatibility. Always 0.
    uint8_t reserved1; // Reserved/Padding. Always 0.
    uint32_t reserved2; // Reserved/Padding. Always 0.
    uint8_t reserved3; // Reserved/Padding. Always 0.
    uint8_t bfCompatFpvCamAngle; // BF compatibility. Always 0.
    uint8_t receiverType; // Receiver type (Parallel PWM, PPM, Serial) (`rxConfig()->receiverType`).
} msp_MSP_RX_CONFIG_reply_t;

#define MSP_RX_CONFIG_REPLY_PAYLOAD_SIZE 24

// MSP_SET_RX_CONFIG
// Sets receiver configuration settings.
// Notes: Expects 24 bytes.
typedef struct MSP_PACKED {
    uint8_t serialRxProvider; // Sets `rxConfigMutable()->serialrx_provider`.
    uint16_t maxCheck; // Sets `rxConfigMutable()->maxcheck`.
    uint16_t midRc; // Ignored (`PWM_RANGE_MIDDLE` is used).
    uint16_t minCheck; // Sets `rxConfigMutable()->mincheck`.
    uint8_t spektrumSatBind; // Sets `rxConfigMutable()->spektrum_sat_bind` (if `USE_SPEKTRUM_BIND`).
    uint16_t rxMinUsec; // Sets `rxConfigMutable()->rx_min_usec`.
    uint16_t rxMaxUsec; // Sets `rxConfigMutable()->rx_max_usec`.
    uint8_t bfCompatRcInterpolation; // Ignored.
    uint8_t bfCompatRcInterpolationInt; // Ignored.
    uint16_t bfCompatAirModeThreshold; // Ignored.
    uint8_t reserved1; // Ignored.
    uint32_t reserved2; // Ignored.
    uint8_t reserved3; // Ignored.
    uint8_t bfCompatFpvCamAngle; // Ignored.
    uint8_t receiverType; // Sets `rxConfigMutable()->receiverType`.
} msp_MSP_SET_RX_CONFIG_request_t;

#define MSP_SET_RX_CONFIG_REQUEST_PAYLOAD_SIZE 24

// No reply payload for MSP_SET_RX_CONFIG.

// MSP_LED_COLORS
// Retrieves the HSV color definitions for configurable LED colors.
// Notes: Only available if `USE_LED_STRIP` is defined.
// No request payload for MSP_LED_COLORS.

typedef struct MSP_PACKED {
    uint16_t hue; // Hue value (0-359).
    uint8_t saturation; // Saturation value (0-255).
    uint8_t value; // Value/Brightness (0-255).
} msp_MSP_LED_COLORS_reply_t;

#define MSP_LED_COLORS_REPLY_PAYLOAD_SIZE 4

// MSP_SET_LED_COLORS
// Sets the HSV color definitions for configurable LED colors.
// Notes: Only available if `USE_LED_STRIP` is defined. Expects `LED_CONFIGURABLE_COLOR_COUNT * 4` bytes.
typedef struct MSP_PACKED {
    uint16_t hue; // Hue value (0-359).
    uint8_t saturation; // Saturation value (0-255).
    uint8_t value; // Value/Brightness (0-255).
} msp_MSP_SET_LED_COLORS_request_t;

#define MSP_SET_LED_COLORS_REQUEST_PAYLOAD_SIZE 4

// No reply payload for MSP_SET_LED_COLORS.

// MSP_LED_STRIP_CONFIG
// Retrieves the configuration for each LED on the strip (legacy packed format).
// Notes: Only available if `USE_LED_STRIP` is defined. Superseded by `MSP2_INAV_LED_STRIP_CONFIG_EX` which uses a clearer struct.
// No request payload for MSP_LED_STRIP_CONFIG.

typedef struct MSP_PACKED {
    uint32_t legacyLedConfig; // Packed LED configuration (position, function, overlay, color, direction, params). See C code for bit packing details.
} msp_MSP_LED_STRIP_CONFIG_reply_t;

#define MSP_LED_STRIP_CONFIG_REPLY_PAYLOAD_SIZE 4

// MSP_SET_LED_STRIP_CONFIG
// Sets the configuration for a single LED on the strip using the legacy packed format.
// Notes: Only available if `USE_LED_STRIP` is defined. Expects 5 bytes. Calls `reevaluateLedConfig()`. Superseded by `MSP2_INAV_SET_LED_STRIP_CONFIG_EX`.
typedef struct MSP_PACKED {
    uint8_t ledIndex; // Index of the LED to configure (0 to `LED_MAX_STRIP_LENGTH - 1`).
    uint32_t legacyLedConfig; // Packed LED configuration to set.
} msp_MSP_SET_LED_STRIP_CONFIG_request_t;

#define MSP_SET_LED_STRIP_CONFIG_REQUEST_PAYLOAD_SIZE 5

// No reply payload for MSP_SET_LED_STRIP_CONFIG.

// MSP_RSSI_CONFIG
// Retrieves the channel used for analog RSSI input.
// No request payload for MSP_RSSI_CONFIG.

typedef struct MSP_PACKED {
    uint8_t rssiChannel; // AUX channel index (1-based) used for RSSI, or 0 if disabled (`rxConfig()->rssi_channel`).
} msp_MSP_RSSI_CONFIG_reply_t;

#define MSP_RSSI_CONFIG_REPLY_PAYLOAD_SIZE 1

// MSP_SET_RSSI_CONFIG
// Sets the channel used for analog RSSI input.
// Notes: Expects 1 byte. Input value is constrained 0 to `MAX_SUPPORTED_RC_CHANNEL_COUNT`. Updates the effective RSSI source.
typedef struct MSP_PACKED {
    uint8_t rssiChannel; // AUX channel index (1-based) to use for RSSI, or 0 to disable.
} msp_MSP_SET_RSSI_CONFIG_request_t;

#define MSP_SET_RSSI_CONFIG_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP_SET_RSSI_CONFIG.

// MSP_ADJUSTMENT_RANGES
// Returns all defined RC adjustment ranges (tuning via aux channels).
// Notes: See `adjustmentRange_t`.
// No request payload for MSP_ADJUSTMENT_RANGES.

typedef struct MSP_PACKED {
    uint8_t adjustmentIndex; // Index of the adjustment slot (0 to `MAX_SIMULTANEOUS_ADJUSTMENT_COUNT - 1`).
    uint8_t auxChannelIndex; // 0-based index of the AUX channel controlling the adjustment value.
    uint8_t rangeStartStep; // Start step (0-20) of the control channel range.
    uint8_t rangeEndStep; // End step (0-20) of the control channel range.
    rcAdjustments.h adjustmentFunction; // Function/parameter being adjusted (e.g., PID gain, rate). See `rcAdjustments.h` enum.
    uint8_t auxSwitchChannelIndex; // 0-based index of the AUX channel acting as an enable switch (or 0 if always enabled).
} msp_MSP_ADJUSTMENT_RANGES_reply_t;

#define MSP_ADJUSTMENT_RANGES_REPLY_PAYLOAD_SIZE 6

// MSP_SET_ADJUSTMENT_RANGE
// Sets a single RC adjustment range configuration by its index.
// Notes: Expects 7 bytes. Returns error if `rangeIndex` or `adjustmentIndex` is invalid.
typedef struct MSP_PACKED {
    uint8_t rangeIndex; // Index of the adjustment range to set (0 to `MAX_ADJUSTMENT_RANGE_COUNT - 1`).
    uint8_t adjustmentIndex; // Adjustment slot index (0 to `MAX_SIMULTANEOUS_ADJUSTMENT_COUNT - 1`).
    uint8_t auxChannelIndex; // 0-based index of the control AUX channel.
    uint8_t rangeStartStep; // Start step (0-20).
    uint8_t rangeEndStep; // End step (0-20).
    uint8_t adjustmentFunction; // Function/parameter being adjusted.
    uint8_t auxSwitchChannelIndex; // 0-based index of the enable switch AUX channel (or 0).
} msp_MSP_SET_ADJUSTMENT_RANGE_request_t;

#define MSP_SET_ADJUSTMENT_RANGE_REQUEST_PAYLOAD_SIZE 7

// No reply payload for MSP_SET_ADJUSTMENT_RANGE.

// MSP_CF_SERIAL_CONFIG
// Deprecated command to get serial port configuration.
// Notes: Not implemented in INAV `fc_msp.c`. Use `MSP2_COMMON_SERIAL_CONFIG`.
// No request payload for MSP_CF_SERIAL_CONFIG.

// No reply payload for MSP_CF_SERIAL_CONFIG.

// MSP_SET_CF_SERIAL_CONFIG
// Deprecated command to set serial port configuration.
// Notes: Not implemented in INAV `fc_msp.c`. Use `MSP2_COMMON_SET_SERIAL_CONFIG`.
// No request payload for MSP_SET_CF_SERIAL_CONFIG.

// No reply payload for MSP_SET_CF_SERIAL_CONFIG.

// MSP_VOLTAGE_METER_CONFIG
// Retrieves legacy voltage meter configuration (scaled values).
// Notes: Superseded by `MSP2_INAV_BATTERY_CONFIG`.
// No request payload for MSP_VOLTAGE_METER_CONFIG.

typedef struct MSP_PACKED {
    uint8_t vbatScale; // Voltage sensor scale factor / 10 (`batteryMetersConfig()->voltage.scale / 10`). 0 if `USE_ADC` disabled.
    uint8_t vbatMinCell; // Minimum cell voltage / 10 (`currentBatteryProfile->voltage.cellMin / 10`). 0 if `USE_ADC` disabled.
    uint8_t vbatMaxCell; // Maximum cell voltage / 10 (`currentBatteryProfile->voltage.cellMax / 10`). 0 if `USE_ADC` disabled.
    uint8_t vbatWarningCell; // Warning cell voltage / 10 (`currentBatteryProfile->voltage.cellWarning / 10`). 0 if `USE_ADC` disabled.
} msp_MSP_VOLTAGE_METER_CONFIG_reply_t;

#define MSP_VOLTAGE_METER_CONFIG_REPLY_PAYLOAD_SIZE 4

// MSP_SET_VOLTAGE_METER_CONFIG
// Sets legacy voltage meter configuration (scaled values).
// Notes: Expects 4 bytes. Superseded by `MSP2_INAV_SET_BATTERY_CONFIG`.
typedef struct MSP_PACKED {
    uint8_t vbatScale; // Sets `batteryMetersConfigMutable()->voltage.scale = value * 10` (if `USE_ADC`).
    uint8_t vbatMinCell; // Sets `currentBatteryProfileMutable->voltage.cellMin = value * 10` (if `USE_ADC`).
    uint8_t vbatMaxCell; // Sets `currentBatteryProfileMutable->voltage.cellMax = value * 10` (if `USE_ADC`).
    uint8_t vbatWarningCell; // Sets `currentBatteryProfileMutable->voltage.cellWarning = value * 10` (if `USE_ADC`).
} msp_MSP_SET_VOLTAGE_METER_CONFIG_request_t;

#define MSP_SET_VOLTAGE_METER_CONFIG_REQUEST_PAYLOAD_SIZE 4

// No reply payload for MSP_SET_VOLTAGE_METER_CONFIG.

// MSP_SONAR_ALTITUDE
// Retrieves the altitude measured by the primary rangefinder (sonar or lidar).
// No request payload for MSP_SONAR_ALTITUDE.

typedef struct MSP_PACKED {
    uint32_t rangefinderAltitude; // Latest altitude reading from the rangefinder (`rangefinderGetLatestAltitude()`). 0 if `USE_RANGEFINDER` disabled or no reading.
} msp_MSP_SONAR_ALTITUDE_reply_t;

#define MSP_SONAR_ALTITUDE_REPLY_PAYLOAD_SIZE 4

// MSP_RX_MAP
// Retrieves the RC channel mapping array (AETR, etc.).
// Notes: `MAX_MAPPABLE_RX_INPUTS` is typically 8 or more.
// No request payload for MSP_RX_MAP.

typedef struct MSP_PACKED {
    uint8_t[MAX_MAPPABLE_RX_INPUTS] rcMap; // Array defining the mapping from input channel index to logical function (Roll, Pitch, Yaw, Throttle, Aux1...).
} msp_MSP_RX_MAP_reply_t;

// #define MSP_RX_MAP_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_SET_RX_MAP
// Sets the RC channel mapping array.
// Notes: Expects `MAX_MAPPABLE_RX_INPUTS` bytes.
typedef struct MSP_PACKED {
    uint8_t[MAX_MAPPABLE_RX_INPUTS] rcMap; // Array defining the new channel mapping.
} msp_MSP_SET_RX_MAP_request_t;

// #define MSP_SET_RX_MAP_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP_SET_RX_MAP.

// MSP_REBOOT
// Commands the flight controller to reboot.
// Notes: The FC sends an ACK *before* rebooting. The `mspPostProcessFn` is set to `mspRebootFn` to perform the reboot after the reply is sent. Will fail if the craft is armed.
// No request payload for MSP_REBOOT.

// No reply payload for MSP_REBOOT.

// MSP_DATAFLASH_SUMMARY
// Retrieves summary information about the onboard dataflash chip (if present and used for Blackbox via FlashFS).
// Notes: Requires `USE_FLASHFS`.
// No request payload for MSP_DATAFLASH_SUMMARY.

typedef struct MSP_PACKED {
    uint8_t flashReady; // Boolean: 1 if flash chip is ready, 0 otherwise. (`flashIsReady()`). 0 if `USE_FLASHFS` disabled.
    uint32_t sectorCount; // Total number of sectors on the flash chip (`geometry->sectors`). 0 if `USE_FLASHFS` disabled.
    uint32_t totalSize; // Total size of the flash chip in bytes (`geometry->totalSize`). 0 if `USE_FLASHFS` disabled.
    uint32_t usedSize; // Currently used size in bytes (FlashFS offset) (`flashfsGetOffset()`). 0 if `USE_FLASHFS` disabled.
} msp_MSP_DATAFLASH_SUMMARY_reply_t;

#define MSP_DATAFLASH_SUMMARY_REPLY_PAYLOAD_SIZE 13

// MSP_DATAFLASH_READ
// Reads a block of data from the onboard dataflash (FlashFS).
// Notes: Requires `USE_FLASHFS`. Read length may be truncated by buffer size or end of flashfs volume.
typedef struct MSP_PACKED {
    uint32_t address; // Starting address to read from within the FlashFS volume.
    uint16_t size; // (Optional) Number of bytes to read. Defaults to 128 if not provided.
} msp_MSP_DATAFLASH_READ_request_t;

#define MSP_DATAFLASH_READ_REQUEST_PAYLOAD_SIZE 6

typedef struct MSP_PACKED {
    uint32_t address; // The starting address from which data was actually read.
    uint8_t[] data; // The data read from flash. Length is MIN(requested size, remaining buffer space, remaining flashfs data).
} msp_MSP_DATAFLASH_READ_reply_t;

// #define MSP_DATAFLASH_READ_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_DATAFLASH_ERASE
// Erases the entire onboard dataflash chip (FlashFS volume).
// Notes: Requires `USE_FLASHFS`. This is a potentially long operation. Use with caution.
// No request payload for MSP_DATAFLASH_ERASE.

// No reply payload for MSP_DATAFLASH_ERASE.

// MSP_LOOP_TIME
// Retrieves the configured loop time (PID loop frequency denominator).
// Notes: This is the *configured* target loop time, not necessarily the *actual* measured cycle time (see `MSP_STATUS`).
// No request payload for MSP_LOOP_TIME.

typedef struct MSP_PACKED {
    uint16_t looptime; // Configured loop time (`gyroConfig()->looptime`).
} msp_MSP_LOOP_TIME_reply_t;

#define MSP_LOOP_TIME_REPLY_PAYLOAD_SIZE 2

// MSP_SET_LOOP_TIME
// Sets the configured loop time.
// Notes: Expects 2 bytes.
typedef struct MSP_PACKED {
    uint16_t looptime; // New loop time to set (`gyroConfigMutable()->looptime`).
} msp_MSP_SET_LOOP_TIME_request_t;

#define MSP_SET_LOOP_TIME_REQUEST_PAYLOAD_SIZE 2

// No reply payload for MSP_SET_LOOP_TIME.

// MSP_FAILSAFE_CONFIG
// Retrieves the failsafe configuration settings.
// No request payload for MSP_FAILSAFE_CONFIG.

typedef struct MSP_PACKED {
    uint8_t failsafeDelay; // Delay before failsafe stage 1 activates (`failsafeConfig()->failsafe_delay`).
    uint8_t failsafeOffDelay; // Delay after signal recovery before returning control (`failsafeConfig()->failsafe_off_delay`).
    uint16_t failsafeThrottle; // Throttle level during failsafe stage 2 (`currentBatteryProfile->failsafe_throttle`).
    uint8_t legacyKillSwitch; // Legacy flag, always 0.
    uint16_t failsafeThrottleLowDelay; // Delay for throttle-based failsafe detection (`failsafeConfig()->failsafe_throttle_low_delay`).
    uint8_t failsafeProcedure; // Failsafe procedure (Drop, RTH, Land, etc.) (`failsafeConfig()->failsafe_procedure`).
    uint8_t failsafeRecoveryDelay; // Delay after RTH finishes before attempting recovery (`failsafeConfig()->failsafe_recovery_delay`).
    uint16_t failsafeFWRollAngle; // Fixed wing failsafe roll angle (`failsafeConfig()->failsafe_fw_roll_angle`).
    uint16_t failsafeFWPitchAngle; // Fixed wing failsafe pitch angle (`failsafeConfig()->failsafe_fw_pitch_angle`).
    uint16_t failsafeFWYawRate; // Fixed wing failsafe yaw rate (`failsafeConfig()->failsafe_fw_yaw_rate`).
    uint16_t failsafeStickThreshold; // Stick movement threshold to exit failsafe (`failsafeConfig()->failsafe_stick_motion_threshold`).
    uint16_t failsafeMinDistance; // Minimum distance from home for RTH failsafe (`failsafeConfig()->failsafe_min_distance`).
    uint8_t failsafeMinDistanceProc; // Failsafe procedure if below min distance (`failsafeConfig()->failsafe_min_distance_procedure`).
} msp_MSP_FAILSAFE_CONFIG_reply_t;

#define MSP_FAILSAFE_CONFIG_REPLY_PAYLOAD_SIZE 20

// MSP_SET_FAILSAFE_CONFIG
// Sets the failsafe configuration settings.
// Notes: Expects 20 bytes.
typedef struct MSP_PACKED {
    uint8_t failsafeDelay; // Sets `failsafeConfigMutable()->failsafe_delay`.
    uint8_t failsafeOffDelay; // Sets `failsafeConfigMutable()->failsafe_off_delay`.
    uint16_t failsafeThrottle; // Sets `currentBatteryProfileMutable->failsafe_throttle`.
    uint8_t legacyKillSwitch; // Ignored.
    uint16_t failsafeThrottleLowDelay; // Sets `failsafeConfigMutable()->failsafe_throttle_low_delay`.
    uint8_t failsafeProcedure; // Sets `failsafeConfigMutable()->failsafe_procedure`.
    uint8_t failsafeRecoveryDelay; // Sets `failsafeConfigMutable()->failsafe_recovery_delay`.
    uint16_t failsafeFWRollAngle; // Sets `failsafeConfigMutable()->failsafe_fw_roll_angle` (casted to `int16_t`).
    uint16_t failsafeFWPitchAngle; // Sets `failsafeConfigMutable()->failsafe_fw_pitch_angle` (casted to `int16_t`).
    uint16_t failsafeFWYawRate; // Sets `failsafeConfigMutable()->failsafe_fw_yaw_rate` (casted to `int16_t`).
    uint16_t failsafeStickThreshold; // Sets `failsafeConfigMutable()->failsafe_stick_motion_threshold`.
    uint16_t failsafeMinDistance; // Sets `failsafeConfigMutable()->failsafe_min_distance`.
    uint8_t failsafeMinDistanceProc; // Sets `failsafeConfigMutable()->failsafe_min_distance_procedure`.
} msp_MSP_SET_FAILSAFE_CONFIG_request_t;

#define MSP_SET_FAILSAFE_CONFIG_REQUEST_PAYLOAD_SIZE 20

// No reply payload for MSP_SET_FAILSAFE_CONFIG.

// MSP_SDCARD_SUMMARY
// Retrieves summary information about the SD card status and filesystem.
// Notes: Requires `USE_SDCARD` and `USE_ASYNCFATFS`.
// No request payload for MSP_SDCARD_SUMMARY.

typedef struct MSP_PACKED {
    uint8_t sdCardSupported; // Bitmask: Bit 0 = 1 if SD card support compiled in (`USE_SDCARD`).
    mspSDCardState_e sdCardState; // Enum (`mspSDCardState_e`): Current state (Not Present, Fatal, Card Init, FS Init, Ready). 0 if `USE_SDCARD` disabled.
    uint8_t fsError; // Last filesystem error code (`afatfs_getLastError()`). 0 if `USE_SDCARD` disabled.
    uint32_t freeSpaceKB; // Free space in KiB (`afatfs_getContiguousFreeSpace() / 1024`). 0 if `USE_SDCARD` disabled.
    uint32_t totalSpaceKB; // Total space in KiB (`sdcard_getMetadata()->numBlocks / 2`). 0 if `USE_SDCARD` disabled.
} msp_MSP_SDCARD_SUMMARY_reply_t;

#define MSP_SDCARD_SUMMARY_REPLY_PAYLOAD_SIZE 11

// MSP_BLACKBOX_CONFIG
// Legacy command to retrieve Blackbox configuration. Superseded by `MSP2_BLACKBOX_CONFIG`.
// Notes: Returns fixed zero values. Use `MSP2_BLACKBOX_CONFIG`.
// No request payload for MSP_BLACKBOX_CONFIG.

typedef struct MSP_PACKED {
    uint8_t blackboxDevice; // Always 0 (API no longer supported).
    uint8_t blackboxRateNum; // Always 0.
    uint8_t blackboxRateDenom; // Always 0.
    uint8_t blackboxPDenom; // Always 0.
} msp_MSP_BLACKBOX_CONFIG_reply_t;

#define MSP_BLACKBOX_CONFIG_REPLY_PAYLOAD_SIZE 4

// MSP_SET_BLACKBOX_CONFIG
// Legacy command to set Blackbox configuration. Superseded by `MSP2_SET_BLACKBOX_CONFIG`.
// Notes: Not implemented in `fc_msp.c`. Use `MSP2_SET_BLACKBOX_CONFIG`.
// No request payload for MSP_SET_BLACKBOX_CONFIG.

// No reply payload for MSP_SET_BLACKBOX_CONFIG.

// MSP_TRANSPONDER_CONFIG
// Get VTX Transponder settings (likely specific to RaceFlight/Betaflight, not standard INAV VTX).
// Notes: Not implemented in INAV `fc_msp.c`.
// No request payload for MSP_TRANSPONDER_CONFIG.

// No reply payload for MSP_TRANSPONDER_CONFIG.

// MSP_SET_TRANSPONDER_CONFIG
// Set VTX Transponder settings.
// Notes: Not implemented in INAV `fc_msp.c`.
// No request payload for MSP_SET_TRANSPONDER_CONFIG.

// No reply payload for MSP_SET_TRANSPONDER_CONFIG.

// MSP_OSD_CONFIG
// Retrieves OSD configuration settings and layout for screen 0.
// Notes: Requires `USE_OSD` for meaningful data, but payload is always sent. Coordinates are packed: `(Y << 8) | X`. See `MSP2_INAV_OSD_*` commands for more detail and multi-layout support.
// No request payload for MSP_OSD_CONFIG.

typedef struct MSP_PACKED {
    uint8_t osdDriverType; // OSD_DRIVER_MAX7456` if `USE_OSD`, else `OSD_DRIVER_NONE`.
    uint8_t videoSystem; // Video system (Auto/PAL/NTSC) (`osdConfig()->video_system`). Sent even if OSD disabled.
    uint8_t units; // Measurement units (Metric/Imperial) (`osdConfig()->units`). Sent even if OSD disabled.
    uint8_t rssiAlarm; // RSSI alarm threshold (`osdConfig()->rssi_alarm`). Sent even if OSD disabled.
    uint16_t capAlarm; // Capacity alarm threshold (`currentBatteryProfile->capacity.warning`). Sent even if OSD disabled.
    uint16_t timerAlarm; // Timer alarm threshold (`osdConfig()->time_alarm`). Sent even if OSD disabled.
    uint16_t altAlarm; // Altitude alarm threshold (`osdConfig()->alt_alarm`). Sent even if OSD disabled.
    uint16_t distAlarm; // Distance alarm threshold (`osdConfig()->dist_alarm`). Sent even if OSD disabled.
    uint16_t negAltAlarm; // Negative altitude alarm threshold (`osdConfig()->neg_alt_alarm`). Sent even if OSD disabled.
    uint16_t[OSD_ITEM_COUNT] itemPositions; // Packed X/Y position for each OSD item on screen 0 (`osdLayoutsConfig()->item_pos[0][i]`). Sent even if OSD disabled.
} msp_MSP_OSD_CONFIG_reply_t;

// #define MSP_OSD_CONFIG_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_SET_OSD_CONFIG
// Sets OSD configuration or a single item's position on screen 0.
// Notes: Requires `USE_OSD`. Distinguishes formats based on the first byte. Format 1 requires at least 10 bytes. Format 2 requires 3 bytes. Triggers an OSD redraw. See `MSP2_INAV_OSD_SET_*` for more advanced control.
// No request payload for MSP_SET_OSD_CONFIG.

// No reply payload for MSP_SET_OSD_CONFIG.

// MSP_OSD_CHAR_READ
// Reads character data from the OSD font memory.
// Notes: Not implemented in INAV `fc_msp.c`. Requires direct hardware access, typically done via DisplayPort.
// No request payload for MSP_OSD_CHAR_READ.

// No reply payload for MSP_OSD_CHAR_READ.

// MSP_OSD_CHAR_WRITE
// Writes character data to the OSD font memory.
// Notes: Requires `USE_OSD`. Payload size determines address size (8/16 bit) and character data size (visible bytes only or full char with metadata). Uses `displayWriteFontCharacter()`. Requires OSD hardware (like MAX7456) to be present and functional.
typedef struct MSP_PACKED {
    uint8_t` or `uint16_t address; // Starting address in font memory. Size depends on total payload size.
    uint8_t[] charData; // Character bitmap data (54 or 64 bytes per char, depending on format).
} msp_MSP_OSD_CHAR_WRITE_request_t;

// #define MSP_OSD_CHAR_WRITE_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP_OSD_CHAR_WRITE.

// MSP_VTX_CONFIG
// Retrieves the current VTX (Video Transmitter) configuration and capabilities.
// Notes: BF compatibility field `frequency` (uint16) is missing compared to some BF versions. Use `MSP_VTXTABLE_BAND` and `MSP_VTXTABLE_POWERLEVEL` for details.
// No request payload for MSP_VTX_CONFIG.

typedef struct MSP_PACKED {
    VTXDEV_* vtxDeviceType; // Enum (`VTXDEV_*`): Type of VTX device detected/configured. `VTXDEV_UNKNOWN` if none.
    uint8_t band; // VTX band number (from `vtxSettingsConfig`).
    uint8_t channel; // VTX channel number (from `vtxSettingsConfig`).
    uint8_t power; // VTX power level index (from `vtxSettingsConfig`).
    uint8_t pitMode; // Boolean: 1 if VTX is currently in pit mode, 0 otherwise.
    uint8_t vtxReady; // Boolean: 1 if VTX device reported ready, 0 otherwise.
    uint8_t lowPowerDisarm; // Boolean: 1 if low power on disarm is enabled (from `vtxSettingsConfig`).
    uint8_t vtxTableAvailable; // Boolean: 1 if VTX tables (band/power) are available for query.
    uint8_t bandCount; // Number of bands supported by the VTX device.
    uint8_t channelCount; // Number of channels per band supported by the VTX device.
    uint8_t powerCount; // Number of power levels supported by the VTX device.
} msp_MSP_VTX_CONFIG_reply_t;

#define MSP_VTX_CONFIG_REPLY_PAYLOAD_SIZE 11

// MSP_SET_VTX_CONFIG
// Sets the VTX configuration (band, channel, power, pit mode). Supports multiple protocol versions/extensions based on payload size.
// Notes: Requires `USE_VTX_CONTROL`. Minimum size 2 bytes. Applies settings to `vtxSettingsConfig` and potentially directly to the device (pit mode).
// No request payload for MSP_SET_VTX_CONFIG.

// No reply payload for MSP_SET_VTX_CONFIG.

// MSP_ADVANCED_CONFIG
// Retrieves advanced hardware-related configuration (PWM protocols, rates). Some fields are BF compatibility placeholders.
// No request payload for MSP_ADVANCED_CONFIG.

typedef struct MSP_PACKED {
    uint8_t gyroSyncDenom; // Always 1 (BF compatibility).
    uint8_t pidProcessDenom; // Always 1 (BF compatibility).
    uint8_t useUnsyncedPwm; // Always 1 (BF compatibility, INAV uses async PWM based on protocol).
    uint8_t motorPwmProtocol; // Motor PWM protocol type (`motorConfig()->motorPwmProtocol`).
    uint16_t motorPwmRate; // Hz: Motor PWM rate (if applicable) (`motorConfig()->motorPwmRate`).
    uint16_t servoPwmRate; // Hz: Servo PWM rate (`servoConfig()->servoPwmRate`).
    uint8_t legacyGyroSync; // Always 0 (BF compatibility).
} msp_MSP_ADVANCED_CONFIG_reply_t;

#define MSP_ADVANCED_CONFIG_REPLY_PAYLOAD_SIZE 9

// MSP_SET_ADVANCED_CONFIG
// Sets advanced hardware-related configuration (PWM protocols, rates).
// Notes: Expects 9 bytes.
typedef struct MSP_PACKED {
    uint8_t gyroSyncDenom; // Ignored.
    uint8_t pidProcessDenom; // Ignored.
    uint8_t useUnsyncedPwm; // Ignored.
    uint8_t motorPwmProtocol; // Sets `motorConfigMutable()->motorPwmProtocol`.
    uint16_t motorPwmRate; // Sets `motorConfigMutable()->motorPwmRate`.
    uint16_t servoPwmRate; // Sets `servoConfigMutable()->servoPwmRate`.
    uint8_t legacyGyroSync; // Ignored.
} msp_MSP_SET_ADVANCED_CONFIG_request_t;

#define MSP_SET_ADVANCED_CONFIG_REQUEST_PAYLOAD_SIZE 9

// No reply payload for MSP_SET_ADVANCED_CONFIG.

// MSP_FILTER_CONFIG
// Retrieves filter configuration settings (Gyro, D-term, Yaw, Accel). Some fields are BF compatibility placeholders or legacy.
// No request payload for MSP_FILTER_CONFIG.

typedef struct MSP_PACKED {
    uint8_t gyroMainLpfHz; // Gyro main low-pass filter cutoff frequency (`gyroConfig()->gyro_main_lpf_hz`).
    uint16_t dtermLpfHz; // D-term low-pass filter cutoff frequency (`pidProfile()->dterm_lpf_hz`).
    uint16_t yawLpfHz; // Yaw low-pass filter cutoff frequency (`pidProfile()->yaw_lpf_hz`).
    uint16_t legacyGyroNotchHz; // Always 0 (Legacy).
    uint16_t legacyGyroNotchCutoff; // Always 1 (Legacy).
    uint16_t bfCompatDtermNotchHz; // Always 0 (BF compatibility).
    uint16_t bfCompatDtermNotchCutoff; // Always 1 (BF compatibility).
    uint16_t bfCompatGyroNotch2Hz; // Always 0 (BF compatibility).
    uint16_t bfCompatGyroNotch2Cutoff; // Always 1 (BF compatibility).
    uint16_t accNotchHz; // Accelerometer notch filter center frequency (`accelerometerConfig()->acc_notch_hz`).
    uint16_t accNotchCutoff; // Accelerometer notch filter cutoff frequency (`accelerometerConfig()->acc_notch_cutoff`).
    uint16_t legacyGyroStage2LpfHz; // Always 0 (Legacy).
} msp_MSP_FILTER_CONFIG_reply_t;

#define MSP_FILTER_CONFIG_REPLY_PAYLOAD_SIZE 23

// MSP_SET_FILTER_CONFIG
// Sets filter configuration settings. Handles different payload lengths for backward compatibility.
// Notes: Requires specific payload sizes (5, 9, 13, 17, 21, or 22 bytes) to be accepted. Calls `pidInitFilters()` if size >= 13.
typedef struct MSP_PACKED {
    uint8_t gyroMainLpfHz; // Sets `gyroConfigMutable()->gyro_main_lpf_hz`. (Size >= 5)
    uint16_t dtermLpfHz; // Sets `pidProfileMutable()->dterm_lpf_hz` (constrained 0-500). (Size >= 5)
    uint16_t yawLpfHz; // Sets `pidProfileMutable()->yaw_lpf_hz` (constrained 0-255). (Size >= 5)
    uint16_t legacyGyroNotchHz; // Ignored. (Size >= 9)
    uint16_t legacyGyroNotchCutoff; // Ignored. (Size >= 9)
    uint16_t bfCompatDtermNotchHz; // Ignored. (Size >= 13)
    uint16_t bfCompatDtermNotchCutoff; // Ignored. (Size >= 13)
    uint16_t bfCompatGyroNotch2Hz; // Ignored. (Size >= 17)
    uint16_t bfCompatGyroNotch2Cutoff; // Ignored. (Size >= 17)
    uint16_t accNotchHz; // Sets `accelerometerConfigMutable()->acc_notch_hz` (constrained 0-255). (Size >= 21)
    uint16_t accNotchCutoff; // Sets `accelerometerConfigMutable()->acc_notch_cutoff` (constrained 1-255). (Size >= 21)
    uint16_t legacyGyroStage2LpfHz; // Ignored. (Size >= 22)
} msp_MSP_SET_FILTER_CONFIG_request_t;

#define MSP_SET_FILTER_CONFIG_REQUEST_PAYLOAD_SIZE 23

// No reply payload for MSP_SET_FILTER_CONFIG.

// MSP_PID_ADVANCED
// Retrieves advanced PID tuning parameters. Many fields are BF compatibility placeholders.
// Notes: Acceleration limits are scaled by 10 for compatibility.
// No request payload for MSP_PID_ADVANCED.

typedef struct MSP_PACKED {
    uint16_t legacyRollPitchItermIgnore; // Always 0 (Legacy).
    uint16_t legacyYawItermIgnore; // Always 0 (Legacy).
    uint16_t legacyYawPLimit; // Always 0 (Legacy).
    uint8_t bfCompatDeltaMethod; // Always 0 (BF compatibility).
    uint8_t bfCompatVbatPidComp; // Always 0 (BF compatibility).
    uint8_t bfCompatSetpointRelaxRatio; // Always 0 (BF compatibility).
    uint8_t reserved1; // Always 0.
    uint16_t legacyPidSumLimit; // Always 0 (Legacy).
    uint8_t bfCompatItermThrottleGain; // Always 0 (BF compatibility).
    uint16_t accelLimitRollPitch; // Axis acceleration limit for Roll/Pitch / 10 (`pidProfile()->axisAccelerationLimitRollPitch / 10`).
    uint16_t accelLimitYaw; // Axis acceleration limit for Yaw / 10 (`pidProfile()->axisAccelerationLimitYaw / 10`).
} msp_MSP_PID_ADVANCED_reply_t;

#define MSP_PID_ADVANCED_REPLY_PAYLOAD_SIZE 17

// MSP_SET_PID_ADVANCED
// Sets advanced PID tuning parameters.
// Notes: Expects 17 bytes.
typedef struct MSP_PACKED {
    uint16_t legacyRollPitchItermIgnore; // Ignored.
    uint16_t legacyYawItermIgnore; // Ignored.
    uint16_t legacyYawPLimit; // Ignored.
    uint8_t bfCompatDeltaMethod; // Ignored.
    uint8_t bfCompatVbatPidComp; // Ignored.
    uint8_t bfCompatSetpointRelaxRatio; // Ignored.
    uint8_t reserved1; // Ignored.
    uint16_t legacyPidSumLimit; // Ignored.
    uint8_t bfCompatItermThrottleGain; // Ignored.
    uint16_t accelLimitRollPitch; // Sets `pidProfileMutable()->axisAccelerationLimitRollPitch = value * 10`.
    uint16_t accelLimitYaw; // Sets `pidProfileMutable()->axisAccelerationLimitYaw = value * 10`.
} msp_MSP_SET_PID_ADVANCED_request_t;

#define MSP_SET_PID_ADVANCED_REQUEST_PAYLOAD_SIZE 17

// No reply payload for MSP_SET_PID_ADVANCED.

// MSP_SENSOR_CONFIG
// Retrieves the configured hardware type for various sensors.
// No request payload for MSP_SENSOR_CONFIG.

typedef struct MSP_PACKED {
    accHardware_e accHardware; // Enum (`accHardware_e`): Accelerometer hardware type (`accelerometerConfig()->acc_hardware`).
    baroHardware_e baroHardware; // Enum (`baroHardware_e`): Barometer hardware type (`barometerConfig()->baro_hardware`). 0 if `USE_BARO` disabled.
    magHardware_e magHardware; // Enum (`magHardware_e`): Magnetometer hardware type (`compassConfig()->mag_hardware`). 0 if `USE_MAG` disabled.
    pitotHardware_e pitotHardware; // Enum (`pitotHardware_e`): Pitot tube hardware type (`pitotmeterConfig()->pitot_hardware`). 0 if `USE_PITOT` disabled.
    rangefinderHardware_e rangefinderHardware; // Enum (`rangefinderHardware_e`): Rangefinder hardware type (`rangefinderConfig()->rangefinder_hardware`). 0 if `USE_RANGEFINDER` disabled.
    opticalFlowHardware_e opflowHardware; // Enum (`opticalFlowHardware_e`): Optical flow hardware type (`opticalFlowConfig()->opflow_hardware`). 0 if `USE_OPFLOW` disabled.
} msp_MSP_SENSOR_CONFIG_reply_t;

#define MSP_SENSOR_CONFIG_REPLY_PAYLOAD_SIZE 6

// MSP_SET_SENSOR_CONFIG
// Sets the configured hardware type for various sensors.
// Notes: Expects 6 bytes.
typedef struct MSP_PACKED {
    uint8_t accHardware; // Sets `accelerometerConfigMutable()->acc_hardware`.
    uint8_t baroHardware; // Sets `barometerConfigMutable()->baro_hardware` (if `USE_BARO`).
    uint8_t magHardware; // Sets `compassConfigMutable()->mag_hardware` (if `USE_MAG`).
    uint8_t pitotHardware; // Sets `pitotmeterConfigMutable()->pitot_hardware` (if `USE_PITOT`).
    uint8_t rangefinderHardware; // Sets `rangefinderConfigMutable()->rangefinder_hardware` (if `USE_RANGEFINDER`).
    uint8_t opflowHardware; // Sets `opticalFlowConfigMutable()->opflow_hardware` (if `USE_OPFLOW`).
} msp_MSP_SET_SENSOR_CONFIG_request_t;

#define MSP_SET_SENSOR_CONFIG_REQUEST_PAYLOAD_SIZE 6

// No reply payload for MSP_SET_SENSOR_CONFIG.

// MSP_SPECIAL_PARAMETERS
// Betaflight specific, likely unused/unimplemented in INAV.
// Notes: Not implemented in INAV `fc_msp.c`.
// No request payload for MSP_SPECIAL_PARAMETERS.

// No reply payload for MSP_SPECIAL_PARAMETERS.

// MSP_SET_SPECIAL_PARAMETERS
// Betaflight specific, likely unused/unimplemented in INAV.
// Notes: Not implemented in INAV `fc_msp.c`.
// No request payload for MSP_SET_SPECIAL_PARAMETERS.

// No reply payload for MSP_SET_SPECIAL_PARAMETERS.

// MSP_IDENT
// Provides basic flight controller identity information. Not implemented in modern INAV, but used by legacy versions and MultiWii.
// Notes: Obsolete. Listed for legacy compatibility only.
// No request payload for MSP_IDENT.

typedef struct MSP_PACKED {
    uint8_t MultiWii_version; // Scaled version major*100+minor
    uint8_t Mixer_Mode; // Mixer type
    uint8_t MSP_Version; // Scaled version major*100+minor
    uint32_t Platform_Capability; 
} msp_MSP_IDENT_reply_t;

#define MSP_IDENT_REPLY_PAYLOAD_SIZE 7

// MSP_STATUS
// Provides basic flight controller status including cycle time, errors, sensor status, active modes (first 32), and the current configuration profile.
// Notes: Superseded by `MSP_STATUS_EX` and `MSP2_INAV_STATUS`. `sensorStatus` bitmask: (Bit 0: ACC, 1: BARO, 2: MAG, 3: GPS, 4: RANGEFINDER, 5: GYRO). `activeModesLow` only contains the first 32 modes; use `MSP_ACTIVEBOXES` for the full set.
// No request payload for MSP_STATUS.

typedef struct MSP_PACKED {
    uint16_t cycleTime; // Main loop cycle time (`cycleTime`).
    uint16_t i2cErrors; // Number of I2C errors encountered (`i2cGetErrorCounter()`). 0 if `USE_I2C` not defined.
    uint16_t sensorStatus; // Bitmask indicating available/active sensors (`packSensorStatus()`). See notes.
    uint32_t activeModesLow; // First 32 bits of the active flight modes bitmask (`packBoxModeFlags()`).
    uint8_t profile; // Current configuration profile index (0-based) (`getConfigProfile()`).
} msp_MSP_STATUS_reply_t;

#define MSP_STATUS_REPLY_PAYLOAD_SIZE 11

// MSP_RAW_IMU
// Provides raw sensor readings from the IMU (Accelerometer, Gyroscope, Magnetometer).
// Notes: Acc scaling is approximate (512 LSB/G). Mag units depend on the sensor.
// No request payload for MSP_RAW_IMU.

typedef struct MSP_PACKED {
    int16_t accX; // Raw accelerometer X reading, scaled (`acc.accADCf[X] * 512`).
    int16_t accY; // Raw accelerometer Y reading, scaled (`acc.accADCf[Y] * 512`).
    int16_t accZ; // Raw accelerometer Z reading, scaled (`acc.accADCf[Z] * 512`).
    int16_t gyroX; // Gyroscope X-axis rate (`gyroRateDps(X)`).
    int16_t gyroY; // Gyroscope Y-axis rate (`gyroRateDps(Y)`).
    int16_t gyroZ; // Gyroscope Z-axis rate (`gyroRateDps(Z)`).
    int16_t magX; // Raw magnetometer X reading (`mag.magADC[X]`). 0 if `USE_MAG` disabled.
    int16_t magY; // Raw magnetometer Y reading (`mag.magADC[Y]`). 0 if `USE_MAG` disabled.
    int16_t magZ; // Raw magnetometer Z reading (`mag.magADC[Z]`). 0 if `USE_MAG` disabled.
} msp_MSP_RAW_IMU_reply_t;

#define MSP_RAW_IMU_REPLY_PAYLOAD_SIZE 18

// MSP_SERVO
// Provides the current output values for all supported servos.
// No request payload for MSP_SERVO.

typedef struct MSP_PACKED {
    int16_t[MAX_SUPPORTED_SERVOS] servoOutputs; // Array of current servo output values (typically 1000-2000).
} msp_MSP_SERVO_reply_t;

// #define MSP_SERVO_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_MOTOR
// Provides the current output values for the first 8 motors.
// No request payload for MSP_MOTOR.

typedef struct MSP_PACKED {
    uint16_t[8] motorOutputs; // Array of current motor output values (typically 1000-2000). Values beyond `MAX_SUPPORTED_MOTORS` are 0.
} msp_MSP_MOTOR_reply_t;

// #define MSP_MOTOR_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_RC
// Provides the current values of the received RC channels.
// No request payload for MSP_RC.

typedef struct MSP_PACKED {
    uint16_t[] rcChannels; // Array of current RC channel values (typically 1000-2000). Length depends on detected channels.
} msp_MSP_RC_reply_t;

// #define MSP_RC_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_RAW_GPS
// Provides raw GPS data (fix status, coordinates, altitude, speed, course).
// Notes: Only available if `USE_GPS` is defined. Altitude is truncated to meters.
// No request payload for MSP_RAW_GPS.

typedef struct MSP_PACKED {
    uint8_t fixType; // GPS fix type (`gpsSol.fixType`).
    uint8_t numSat; // Number of satellites used in solution (`gpsSol.numSat`).
    int32_t latitude; // Latitude (`gpsSol.llh.lat`).
    int32_t longitude; // Longitude (`gpsSol.llh.lon`).
    int16_t altitude; // Altitude above MSL (`gpsSol.llh.alt / 100`).
    uint16_t speed; // Ground speed (`gpsSol.groundSpeed`).
    uint16_t groundCourse; // Ground course (`gpsSol.groundCourse`).
    uint16_t hdop; // Horizontal Dilution of Precision (`gpsSol.hdop`).
} msp_MSP_RAW_GPS_reply_t;

#define MSP_RAW_GPS_REPLY_PAYLOAD_SIZE 18

// MSP_COMP_GPS
// Provides computed GPS values: distance and direction to home.
// Notes: Only available if `USE_GPS` is defined.
// No request payload for MSP_COMP_GPS.

typedef struct MSP_PACKED {
    uint16_t distanceToHome; // Distance to the home point (`GPS_distanceToHome`).
    uint16_t directionToHome; // Direction to the home point (0-360) (`GPS_directionToHome`).
    uint8_t gpsHeartbeat; // Indicates if GPS data is being received (`gpsSol.flags.gpsHeartbeat`).
} msp_MSP_COMP_GPS_reply_t;

#define MSP_COMP_GPS_REPLY_PAYLOAD_SIZE 5

// MSP_ATTITUDE
// Provides the current attitude estimate (roll, pitch, yaw).
// Notes: Yaw is converted from deci-degrees to degrees.
// No request payload for MSP_ATTITUDE.

typedef struct MSP_PACKED {
    int16_t roll; // Roll angle (`attitude.values.roll`).
    int16_t pitch; // Pitch angle (`attitude.values.pitch`).
    int16_t yaw; // Yaw/Heading angle (`DECIDEGREES_TO_DEGREES(attitude.values.yaw)`).
} msp_MSP_ATTITUDE_reply_t;

#define MSP_ATTITUDE_REPLY_PAYLOAD_SIZE 6

// MSP_ALTITUDE
// Provides estimated altitude, vertical speed (variometer), and raw barometric altitude.
// No request payload for MSP_ALTITUDE.

typedef struct MSP_PACKED {
    int32_t estimatedAltitude; // Estimated altitude above home/sea level (`getEstimatedActualPosition(Z)`).
    int16_t variometer; // Estimated vertical speed (`getEstimatedActualVelocity(Z)`).
    int32_t baroAltitude; // Latest raw altitude from barometer (`baroGetLatestAltitude()`). 0 if `USE_BARO` disabled.
} msp_MSP_ALTITUDE_reply_t;

#define MSP_ALTITUDE_REPLY_PAYLOAD_SIZE 10

// MSP_ANALOG
// Provides analog sensor readings: battery voltage, current consumption (mAh), RSSI, and current draw (Amps).
// Notes: Superseded by `MSP2_INAV_ANALOG` which provides higher precision and more fields.
// No request payload for MSP_ANALOG.

typedef struct MSP_PACKED {
    uint8_t vbat; // Battery voltage, scaled (`getBatteryVoltage() / 10`), constrained 0-255.
    uint16_t mAhDrawn; // Consumed battery capacity (`getMAhDrawn()`), constrained 0-65535.
    uint16_t rssi; // Received Signal Strength Indicator (`getRSSI()`). Units depend on source.
    int16_t amperage; // Current draw (`getAmperage()`), constrained -32768 to 32767.
} msp_MSP_ANALOG_reply_t;

#define MSP_ANALOG_REPLY_PAYLOAD_SIZE 7

// MSP_RC_TUNING
// Retrieves RC tuning parameters (rates, expos, TPA) for the current control rate profile.
// Notes: Superseded by `MSP2_INAV_RATE_PROFILE` which includes manual rates/expos.
// No request payload for MSP_RC_TUNING.

typedef struct MSP_PACKED {
    uint8_t legacyRcRate; // Always 100 (Legacy, unused).
    uint8_t rcExpo; // Roll/Pitch RC Expo (`currentControlRateProfile->stabilized.rcExpo8`).
    uint8_t rollRate; // Roll Rate (`currentControlRateProfile->stabilized.rates[FD_ROLL]`).
    uint8_t pitchRate; // Pitch Rate (`currentControlRateProfile->stabilized.rates[FD_PITCH]`).
    uint8_t yawRate; // Yaw Rate (`currentControlRateProfile->stabilized.rates[FD_YAW]`).
    uint8_t dynamicThrottlePID; // Dynamic Throttle PID (TPA) value (`currentControlRateProfile->throttle.dynPID`).
    uint8_t throttleMid; // Throttle Midpoint (`currentControlRateProfile->throttle.rcMid8`).
    uint8_t throttleExpo; // Throttle Expo (`currentControlRateProfile->throttle.rcExpo8`).
    uint16_t tpaBreakpoint; // Throttle PID Attenuation (TPA) breakpoint (`currentControlRateProfile->throttle.pa_breakpoint`).
    uint8_t rcYawExpo; // Yaw RC Expo (`currentControlRateProfile->stabilized.rcYawExpo8`).
} msp_MSP_RC_TUNING_reply_t;

#define MSP_RC_TUNING_REPLY_PAYLOAD_SIZE 11

// MSP_ACTIVEBOXES
// Provides the full bitmask of currently active flight modes (boxes).
// Notes: Use this instead of `MSP_STATUS` or `MSP_STATUS_EX` if more than 32 modes are possible.
// No request payload for MSP_ACTIVEBOXES.

typedef struct MSP_PACKED {
    boxBitmask_t activeModes; // Bitmask of all active modes (`packBoxModeFlags()`). Size depends on `boxBitmask_t` definition.
} msp_MSP_ACTIVEBOXES_reply_t;

// #define MSP_ACTIVEBOXES_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_MISC
// Retrieves miscellaneous configuration settings, mostly related to RC, GPS, Mag, and Battery voltage (legacy formats).
// Notes: Superseded by `MSP2_INAV_MISC` and other specific commands which offer better precision and more fields.
// No request payload for MSP_MISC.

typedef struct MSP_PACKED {
    uint16_t midRc; // Mid RC value (`PWM_RANGE_MIDDLE`, typically 1500).
    uint16_t legacyMinThrottle; // Always 0 (Legacy).
    uint16_t maxThrottle; // Maximum throttle command (`getMaxThrottle()`).
    uint16_t minCommand; // Minimum motor command when disarmed (`motorConfig()->mincommand`).
    uint16_t failsafeThrottle; // Failsafe throttle level (`currentBatteryProfile->failsafe_throttle`).
    uint8_t gpsType; // GPS provider type (`gpsConfig()->provider`). 0 if `USE_GPS` disabled.
    uint8_t legacyGpsBaud; // Always 0 (Legacy).
    uint8_t gpsSbasMode; // GPS SBAS mode (`gpsConfig()->sbasMode`). 0 if `USE_GPS` disabled.
    uint8_t legacyMwCurrentOut; // Always 0 (Legacy).
    uint8_t rssiChannel; // RSSI channel index (1-based) (`rxConfig()->rssi_channel`).
    uint8_t reserved1; // Always 0.
    uint16_t magDeclination; // Magnetic declination / 10 (`compassConfig()->mag_declination / 10`). 0 if `USE_MAG` disabled.
    uint8_t vbatScale; // Voltage scale / 10 (`batteryMetersConfig()->voltage.scale / 10`). 0 if `USE_ADC` disabled.
    uint8_t vbatMinCell; // Min cell voltage / 10 (`currentBatteryProfile->voltage.cellMin / 10`). 0 if `USE_ADC` disabled.
    uint8_t vbatMaxCell; // Max cell voltage / 10 (`currentBatteryProfile->voltage.cellMax / 10`). 0 if `USE_ADC` disabled.
    uint8_t vbatWarningCell; // Warning cell voltage / 10 (`currentBatteryProfile->voltage.cellWarning / 10`). 0 if `USE_ADC` disabled.
} msp_MSP_MISC_reply_t;

#define MSP_MISC_REPLY_PAYLOAD_SIZE 22

// MSP_BOXNAMES
// Provides a semicolon-separated string containing the names of all available flight modes (boxes).
// Notes: The exact set of names depends on compiled features and configuration. Due to the size of the payload, it is recommended that [`MSP_BOXIDS`](#msp_boxids-119--0x77) is used instead.
// No request payload for MSP_BOXNAMES.

typedef struct MSP_PACKED {
    char boxNamesString[]; // String containing mode names separated by ';'. Null termination not guaranteed by MSP, relies on payload size. (`serializeBoxNamesReply()`).
} msp_MSP_BOXNAMES_reply_t;

// #define MSP_BOXNAMES_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_PIDNAMES
// Provides a semicolon-separated string containing the names of the PID controllers.
// No request payload for MSP_PIDNAMES.

typedef struct MSP_PACKED {
    char pidNamesString[]; // String "ROLL;PITCH;YAW;ALT;Pos;PosR;NavR;LEVEL;MAG;VEL;". Null termination not guaranteed by MSP.
} msp_MSP_PIDNAMES_reply_t;

// #define MSP_PIDNAMES_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_WP
// Get/Set a single waypoint from the mission plan.
// Notes: See `navWaypoint_t` and `navWaypointAction_e`.
typedef struct MSP_PACKED {
    uint8_t waypointIndex; // Index of the waypoint to retrieve (0 to `NAV_MAX_WAYPOINTS - 1`).
} msp_MSP_WP_request_t;

#define MSP_WP_REQUEST_PAYLOAD_SIZE 1

typedef struct MSP_PACKED {
    uint8_t waypointIndex; // Index of the returned waypoint.
    uint8_t action; // Waypoint action type (`navWaypointAction_e`).
    int32_t latitude; // Latitude coordinate.
    int32_t longitude; // Longitude coordinate.
    int32_t altitude; // Altitude coordinate (relative to home or sea level, see flag).
    uint16_t param1; // Parameter 1 (meaning depends on action).
    uint16_t param2; // Parameter 2 (meaning depends on action).
    uint16_t param3; // Parameter 3 (meaning depends on action).
    uint8_t flag; // Waypoint flags (`NAV_WP_FLAG_*`).
} msp_MSP_WP_reply_t;

#define MSP_WP_REPLY_PAYLOAD_SIZE 21

// MSP_BOXIDS
// Provides a list of permanent IDs associated with the available flight modes (boxes).
// Notes: Useful for mapping mode range configurations (`MSP_MODE_RANGES`) back to user-understandable modes via `MSP_BOXNAMES`.
// No request payload for MSP_BOXIDS.

typedef struct MSP_PACKED {
    uint8_t[] boxIds; // Array of permanent IDs for each configured box (`serializeBoxReply()`). Length depends on number of boxes.
} msp_MSP_BOXIDS_reply_t;

// #define MSP_BOXIDS_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_SERVO_CONFIGURATIONS
// Retrieves the configuration parameters for all supported servos (min, max, middle, rate). Legacy format with unused fields.
// Notes: Superseded by `MSP2_INAV_SERVO_CONFIG` which has a cleaner structure.
// No request payload for MSP_SERVO_CONFIGURATIONS.

typedef struct MSP_PACKED {
    uint16_t min; // Minimum servo endpoint (`servoParams(i)->min`).
    uint16_t max; // Maximum servo endpoint (`servoParams(i)->max`).
    uint16_t middle; // Middle/Neutral servo position (`servoParams(i)->middle`).
    uint8_t rate; // Servo rate/scaling (`servoParams(i)->rate`).
    uint8_t reserved1; // Always 0.
    uint8_t reserved2; // Always 0.
    uint8_t legacyForwardChan; // Always 255 (Legacy).
    uint32_t legacyReversedSources; // Always 0 (Legacy).
} msp_MSP_SERVO_CONFIGURATIONS_reply_t;

#define MSP_SERVO_CONFIGURATIONS_REPLY_PAYLOAD_SIZE 14

// MSP_NAV_STATUS
// Retrieves the current status of the navigation system.
// Notes: Requires `USE_GPS`.
// No request payload for MSP_NAV_STATUS.

typedef struct MSP_PACKED {
    NAV_MODE_* navMode; // Enum (`NAV_MODE_*`): Current navigation mode (None, RTH, WP, Hold, etc.) (`NAV_Status.mode`).
    NAV_STATE_* navState; // Enum (`NAV_STATE_*`): Current navigation state (`NAV_Status.state`).
    navWaypointAction_e activeWpAction; // Enum (`navWaypointAction_e`): Action of the currently executing waypoint (`NAV_Status.activeWpAction`).
    uint8_t activeWpNumber; // Index: Index of the currently executing waypoint (`NAV_Status.activeWpNumber`).
    NAV_ERROR_* navError; // Enum (`NAV_ERROR_*`): Current navigation error code (`NAV_Status.error`).
    int16_t targetHeading; // degrees: Target heading for heading controller (`getHeadingHoldTarget()`).
} msp_MSP_NAV_STATUS_reply_t;

#define MSP_NAV_STATUS_REPLY_PAYLOAD_SIZE 7

// MSP_NAV_CONFIG
// No request payload for MSP_NAV_CONFIG.

// No reply payload for MSP_NAV_CONFIG.

// MSP_3D
// Retrieves settings related to 3D/reversible motor operation.
// Notes: Requires reversible motor support.
// No request payload for MSP_3D.

typedef struct MSP_PACKED {
    uint16_t deadbandLow; // Lower deadband limit for 3D mode (`reversibleMotorsConfig()->deadband_low`).
    uint16_t deadbandHigh; // Upper deadband limit for 3D mode (`reversibleMotorsConfig()->deadband_high`).
    uint16_t neutral; // Neutral throttle point for 3D mode (`reversibleMotorsConfig()->neutral`).
} msp_MSP_3D_reply_t;

#define MSP_3D_REPLY_PAYLOAD_SIZE 6

// MSP_RC_DEADBAND
// Retrieves RC input deadband settings.
// No request payload for MSP_RC_DEADBAND.

typedef struct MSP_PACKED {
    uint8_t deadband; // General RC deadband for Roll/Pitch (`rcControlsConfig()->deadband`).
    uint8_t yawDeadband; // Specific deadband for Yaw (`rcControlsConfig()->yaw_deadband`).
    uint8_t altHoldDeadband; // Deadband for altitude hold adjustments (`rcControlsConfig()->alt_hold_deadband`).
    uint16_t throttleDeadband; // Deadband around throttle mid-stick (`rcControlsConfig()->mid_throttle_deadband`).
} msp_MSP_RC_DEADBAND_reply_t;

#define MSP_RC_DEADBAND_REPLY_PAYLOAD_SIZE 5

// MSP_SENSOR_ALIGNMENT
// Retrieves sensor alignment settings (legacy format).
// Notes: Board alignment is now typically handled by `MSP_BOARD_ALIGNMENT`. This returns legacy enum values where applicable.
// No request payload for MSP_SENSOR_ALIGNMENT.

typedef struct MSP_PACKED {
    uint8_t gyroAlign; // Always 0 (Legacy alignment enum).
    uint8_t accAlign; // Always 0 (Legacy alignment enum).
    uint8_t magAlign; // Magnetometer alignment (`compassConfig()->mag_align`). 0 if `USE_MAG` disabled.
    uint8_t opflowAlign; // Optical flow alignment (`opticalFlowConfig()->opflow_align`). 0 if `USE_OPFLOW` disabled.
} msp_MSP_SENSOR_ALIGNMENT_reply_t;

#define MSP_SENSOR_ALIGNMENT_REPLY_PAYLOAD_SIZE 4

// MSP_LED_STRIP_MODECOLOR
// Retrieves the color index assigned to each LED mode and function/direction combination, including special colors.
// Notes: Only available if `USE_LED_STRIP` is defined. Allows mapping modes/directions/specials to configured colors.
// No request payload for MSP_LED_STRIP_MODECOLOR.

typedef struct MSP_PACKED {
    uint8_t modeIndex; // Index of the LED mode (`ledModeIndex_e`). `LED_MODE_COUNT` for special colors.
    uint8_t directionOrSpecialIndex; // Index of the direction (`ledDirection_e`) or special color (`ledSpecialColor_e`).
    uint8_t colorIndex; // Index of the color assigned from `ledStripConfig()->colors`.
} msp_MSP_LED_STRIP_MODECOLOR_reply_t;

#define MSP_LED_STRIP_MODECOLOR_REPLY_PAYLOAD_SIZE 3

// MSP_BATTERY_STATE
// Provides battery state information, formatted primarily for DJI FPV Goggles compatibility.
// Notes: Only available if `USE_DJI_HD_OSD` or `USE_MSP_DISPLAYPORT` is defined. Some values are duplicated from `MSP_ANALOG` / `MSP2_INAV_ANALOG` but potentially with different scaling/types.
// No request payload for MSP_BATTERY_STATE.

typedef struct MSP_PACKED {
    uint8_t cellCount; // Number of battery cells (`getBatteryCellCount()`).
    uint16_t capacity; // Battery capacity (`currentBatteryProfile->capacity.value`).
    uint8_t vbatScaled; // Battery voltage / 10 (`getBatteryVoltage() / 10`).
    uint16_t mAhDrawn; // Consumed capacity (`getMAhDrawn()`).
    int16_t amperage; // Current draw (`getAmperage()`).
    uint8_t batteryState; // Current battery state (`getBatteryState()`, see `BATTERY_STATE_*`).
    uint16_t vbatActual; // Actual battery voltage (`getBatteryVoltage()`).
} msp_MSP_BATTERY_STATE_reply_t;

#define MSP_BATTERY_STATE_REPLY_PAYLOAD_SIZE 11

// MSP_VTXTABLE_BAND
// Retrieves information about a specific VTX band from the VTX table. (Implementation missing in provided `fc_msp.c`)
// Notes: The ID is defined, but no handler exists in the provided C code. Likely intended to query band names and frequencies.
// No request payload for MSP_VTXTABLE_BAND.

// No reply payload for MSP_VTXTABLE_BAND.

// MSP_VTXTABLE_POWERLEVEL
// Retrieves information about a specific VTX power level from the VTX table.
// Notes: Requires `USE_VTX_CONTROL`. Returns error if index is out of bounds. The `powerValue` field is unused.
typedef struct MSP_PACKED {
    uint8_t powerLevelIndex; // 1-based index of the power level to query.
} msp_MSP_VTXTABLE_POWERLEVEL_request_t;

#define MSP_VTXTABLE_POWERLEVEL_REQUEST_PAYLOAD_SIZE 1

typedef struct MSP_PACKED {
    uint8_t powerLevelIndex; // 1-based index of the returned power level.
    uint16_t powerValue; // Always 0 (Actual power value in mW is not stored/returned via MSP).
    uint8_t labelLength; // Length of the power level label string that follows.
    char label[]; // Power level label string (e.g., "25", "200"). Length given by previous field.
} msp_MSP_VTXTABLE_POWERLEVEL_reply_t;

// #define MSP_VTXTABLE_POWERLEVEL_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_STATUS_EX
// Provides extended flight controller status, including CPU load, arming flags, and calibration status, in addition to `MSP_STATUS` fields.
// Notes: Superseded by `MSP2_INAV_STATUS` which provides the full 32-bit `armingFlags` and other enhancements.
// No request payload for MSP_STATUS_EX.

typedef struct MSP_PACKED {
    uint16_t cycleTime; // Main loop cycle time.
    uint16_t i2cErrors; // I2C errors.
    uint16_t sensorStatus; // Sensor status bitmask.
    uint32_t activeModesLow; // First 32 active modes.
    uint8_t profile; // Current config profile index.
    uint16_t cpuLoad; // Average system load percentage (`averageSystemLoadPercent`).
    uint16_t armingFlags; // Flight controller arming flags (`armingFlags`). Note: Truncated to 16 bits.
    uint8_t accCalibAxisFlags; // Accelerometer calibrated axes flags (`accGetCalibrationAxisFlags()`).
} msp_MSP_STATUS_EX_reply_t;

#define MSP_STATUS_EX_REPLY_PAYLOAD_SIZE 16

// MSP_SENSOR_STATUS
// Provides the hardware status for each individual sensor system.
// Notes: Status values likely correspond to `SENSOR_STATUS_*` enums (e.g., OK, Unhealthy, Not Present).
// No request payload for MSP_SENSOR_STATUS.

typedef struct MSP_PACKED {
    uint8_t overallHealth; // 1 if all essential hardware is healthy, 0 otherwise (`isHardwareHealthy()`).
    uint8_t gyroStatus; // Gyro hardware status (`getHwGyroStatus()`).
    uint8_t accStatus; // Accelerometer hardware status (`getHwAccelerometerStatus()`).
    uint8_t magStatus; // Compass hardware status (`getHwCompassStatus()`).
    uint8_t baroStatus; // Barometer hardware status (`getHwBarometerStatus()`).
    uint8_t gpsStatus; // GPS hardware status (`getHwGPSStatus()`).
    uint8_t rangefinderStatus; // Rangefinder hardware status (`getHwRangefinderStatus()`).
    uint8_t pitotStatus; // Pitot hardware status (`getHwPitotmeterStatus()`).
    uint8_t opflowStatus; // Optical Flow hardware status (`getHwOpticalFlowStatus()`).
} msp_MSP_SENSOR_STATUS_reply_t;

#define MSP_SENSOR_STATUS_REPLY_PAYLOAD_SIZE 9

// MSP_UID
// Provides the unique identifier of the microcontroller.
// Notes: Total 12 bytes, representing a 96-bit unique ID.
// No request payload for MSP_UID.

typedef struct MSP_PACKED {
    uint32_t uid0; // First 32 bits of the unique ID (`U_ID_0`).
    uint32_t uid1; // Middle 32 bits of the unique ID (`U_ID_1`).
    uint32_t uid2; // Last 32 bits of the unique ID (`U_ID_2`).
} msp_MSP_UID_reply_t;

#define MSP_UID_REPLY_PAYLOAD_SIZE 12

// MSP_GPSSVINFO
// Provides satellite signal strength information (legacy U-Blox compatibility stub).
// Notes: Requires `USE_GPS`. This is just a stub in INAV and does not provide actual per-satellite signal info. `hdopUnits` duplicates `hdopHundreds`.
// No request payload for MSP_GPSSVINFO.

typedef struct MSP_PACKED {
    uint8_t protocolVersion; // Always 1 (Stub version).
    uint8_t numChannels; // Always 0 (Number of SV info channels reported).
    uint8_t hdopHundreds; // HDOP / 100 (`gpsSol.hdop / 100`).
    uint8_t hdopUnits; // HDOP / 100 (`gpsSol.hdop / 100`).
} msp_MSP_GPSSVINFO_reply_t;

#define MSP_GPSSVINFO_REPLY_PAYLOAD_SIZE 4

// MSP_GPSSTATISTICS
// Provides debugging statistics for the GPS communication link.
// Notes: Requires `USE_GPS`.
// No request payload for MSP_GPSSTATISTICS.

typedef struct MSP_PACKED {
    uint16_t lastMessageDt; // Time since last valid GPS message (`gpsStats.lastMessageDt`).
    uint32_t errors; // Number of GPS communication errors (`gpsStats.errors`).
    uint32_t timeouts; // Number of GPS communication timeouts (`gpsStats.timeouts`).
    uint32_t packetCount; // Number of valid GPS packets received (`gpsStats.packetCount`).
    uint16_t hdop; // Horizontal Dilution of Precision (`gpsSol.hdop`).
    uint16_t eph; // Estimated Horizontal Position Accuracy (`gpsSol.eph`).
    uint16_t epv; // Estimated Vertical Position Accuracy (`gpsSol.epv`).
} msp_MSP_GPSSTATISTICS_reply_t;

#define MSP_GPSSTATISTICS_REPLY_PAYLOAD_SIZE 20

// MSP_SET_TX_INFO
// Allows a transmitter LUA script (or similar) to send runtime information (currently only RSSI) to the firmware.
// Notes: Calls `setRSSIFromMSP()`. Expects 1 byte.
typedef struct MSP_PACKED {
    uint8_t rssi; // RSSI value (0-100) provided by the external source.
} msp_MSP_SET_TX_INFO_request_t;

#define MSP_SET_TX_INFO_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP_SET_TX_INFO.

// MSP_TX_INFO
// Provides information potentially useful for transmitter LUA scripts.
// Notes: See `rssiSource_e`.
// No request payload for MSP_TX_INFO.

typedef struct MSP_PACKED {
    getRSSISource() rssiSource; // Enum: Source of the RSSI value (`getRSSISource()`).
    uint8_t rtcDateTimeIsSet; // Boolean: 1 if the RTC has been set, 0 otherwise.
} msp_MSP_TX_INFO_reply_t;

#define MSP_TX_INFO_REPLY_PAYLOAD_SIZE 2

// MSP_SET_RAW_RC
// Provides raw RC channel data to the flight controller, typically used when the receiver is connected via MSP (e.g., MSP RX feature).
// Notes: Requires `USE_RX_MSP`. Maximum channels `MAX_SUPPORTED_RC_CHANNEL_COUNT`. Calls `rxMspFrameReceive()`.
typedef struct MSP_PACKED {
    uint16_t[] rcChannels; // Array of RC channel values (typically 1000-2000). Number of channels determined by payload size.
} msp_MSP_SET_RAW_RC_request_t;

// #define MSP_SET_RAW_RC_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP_SET_RAW_RC.

// MSP_SET_RAW_GPS
// Provides raw GPS data to the flight controller, typically for simulation or external GPS injection.
// Notes: Requires `USE_GPS`. Expects 14 bytes. Updates `gpsSol` structure and calls `onNewGPSData()`. Note the altitude unit mismatch (meters in MSP, cm internal). Does not provide velocity components.
typedef struct MSP_PACKED {
    uint8_t fixType; // GPS fix type.
    uint8_t numSat; // Number of satellites.
    int32_t latitude; // Latitude.
    int32_t longitude; // Longitude.
    int16_t altitude; // Altitude (converted to cm internally).
    uint16_t speed; // Ground speed.
    uint16_t groundCourse; // Ground course (units unclear from code, likely degrees or deci-degrees, ignored in current code).
} msp_MSP_SET_RAW_GPS_request_t;

#define MSP_SET_RAW_GPS_REQUEST_PAYLOAD_SIZE 16

// No reply payload for MSP_SET_RAW_GPS.

// MSP_SET_BOX
// Sets the state of flight modes (boxes). (Likely unused/obsolete in INAV).
// Notes: Not implemented in INAV `fc_msp.c`. Mode changes are typically handled via RC channels (`MSP_MODE_RANGES`).
// No request payload for MSP_SET_BOX.

// No reply payload for MSP_SET_BOX.

// MSP_SET_RC_TUNING
// Sets RC tuning parameters (rates, expos, TPA) for the current control rate profile.
// Notes: Expects 10 or 11 bytes. Calls `schedulePidGainsUpdate()`. Superseded by `MSP2_INAV_SET_RATE_PROFILE`.
typedef struct MSP_PACKED {
    uint8_t legacyRcRate; // Ignored.
    uint8_t rcExpo; // Sets `currentControlRateProfile->stabilized.rcExpo8`.
    uint8_t rollRate; // Sets `currentControlRateProfile->stabilized.rates[FD_ROLL]` (constrained).
    uint8_t pitchRate; // Sets `currentControlRateProfile->stabilized.rates[FD_PITCH]` (constrained).
    uint8_t yawRate; // Sets `currentControlRateProfile->stabilized.rates[FD_YAW]` (constrained).
    uint8_t dynamicThrottlePID; // Sets `currentControlRateProfile->throttle.dynPID` (constrained).
    uint8_t throttleMid; // Sets `currentControlRateProfile->throttle.rcMid8`.
    uint8_t throttleExpo; // Sets `currentControlRateProfile->throttle.rcExpo8`.
    uint16_t tpaBreakpoint; // Sets `currentControlRateProfile->throttle.pa_breakpoint`.
    uint8_t rcYawExpo; // (Optional) Sets `currentControlRateProfile->stabilized.rcYawExpo8`.
} msp_MSP_SET_RC_TUNING_request_t;

#define MSP_SET_RC_TUNING_REQUEST_PAYLOAD_SIZE 11

// No reply payload for MSP_SET_RC_TUNING.

// MSP_ACC_CALIBRATION
// Starts the accelerometer calibration procedure.
// Notes: Will fail if armed. Calls `accStartCalibration()`.
// No request payload for MSP_ACC_CALIBRATION.

// No reply payload for MSP_ACC_CALIBRATION.

// MSP_MAG_CALIBRATION
// Starts the magnetometer calibration procedure.
// Notes: Will fail if armed. Enables the `CALIBRATE_MAG` state flag.
// No request payload for MSP_MAG_CALIBRATION.

// No reply payload for MSP_MAG_CALIBRATION.

// MSP_SET_MISC
// Sets miscellaneous configuration settings (legacy formats/scaling).
// Notes: Expects 22 bytes. Superseded by `MSP2_INAV_SET_MISC`.
typedef struct MSP_PACKED {
    uint16_t midRc; // Ignored.
    uint16_t legacyMinThrottle; // Ignored.
    uint16_t legacyMaxThrottle; // Ignored.
    uint16_t minCommand; // Sets `motorConfigMutable()->mincommand` (constrained 0-PWM_RANGE_MAX).
    uint16_t failsafeThrottle; // Sets `currentBatteryProfileMutable->failsafe_throttle` (constrained PWM_RANGE_MIN/MAX).
    uint8_t gpsType; // gpsProvider_e` (Sets `gpsConfigMutable()->provider`)
    uint8_t legacyGpsBaud; // Ignored.
    uint8_t gpsSbasMode; // sbasMode_e` (Sets `gpsConfigMutable()->sbasMode`)
    uint8_t legacyMwCurrentOut; // Ignored.
    uint8_t rssiChannel; // Sets `rxConfigMutable()->rssi_channel` (constrained 0-MAX_SUPPORTED_RC_CHANNEL_COUNT). Updates source.
    uint8_t reserved1; // Ignored.
    uint16_t magDeclination; // Sets `compassConfigMutable()->mag_declination = value * 10` (if `USE_MAG`).
    uint8_t vbatScale; // Sets `batteryMetersConfigMutable()->voltage.scale = value * 10` (if `USE_ADC`).
    uint8_t vbatMinCell; // Sets `currentBatteryProfileMutable->voltage.cellMin = value * 10` (if `USE_ADC`).
    uint8_t vbatMaxCell; // Sets `currentBatteryProfileMutable->voltage.cellMax = value * 10` (if `USE_ADC`).
    uint8_t vbatWarningCell; // Sets `currentBatteryProfileMutable->voltage.cellWarning = value * 10` (if `USE_ADC`).
} msp_MSP_SET_MISC_request_t;

#define MSP_SET_MISC_REQUEST_PAYLOAD_SIZE 22

// No reply payload for MSP_SET_MISC.

// MSP_RESET_CONF
// Resets all configuration settings to their default values and saves to EEPROM.
// Notes: Will fail if armed. Suspends RX, calls `resetEEPROM()`, `writeEEPROM()`, `readEEPROM()`, resumes RX. Use with caution!
// No request payload for MSP_RESET_CONF.

// No reply payload for MSP_RESET_CONF.

// MSP_SET_WP
// Sets a single waypoint in the mission plan.
// Notes: Expects 21 bytes. Calls `setWaypoint()`. If `USE_FW_AUTOLAND` is enabled, this also interacts with autoland approach settings based on waypoint index and flags.
typedef struct MSP_PACKED {
    uint8_t waypointIndex; // Index of the waypoint to set (0 to `NAV_MAX_WAYPOINTS - 1`).
    uint8_t action; // Waypoint action type.
    int32_t latitude; // Latitude coordinate.
    int32_t longitude; // Longitude coordinate.
    int32_t altitude; // Altitude coordinate.
    uint16_t param1; // Parameter 1.
    uint16_t param2; // Parameter 2.
    uint16_t param3; // Parameter 3.
    uint8_t flag; // Waypoint flags.
} msp_MSP_SET_WP_request_t;

#define MSP_SET_WP_REQUEST_PAYLOAD_SIZE 21

// No reply payload for MSP_SET_WP.

// MSP_SELECT_SETTING
// Selects the active configuration profile and saves it.
// Notes: Will fail if armed. Calls `setConfigProfileAndWriteEEPROM()`.
typedef struct MSP_PACKED {
    uint8_t profileIndex; // Index of the profile to activate (0-based).
} msp_MSP_SELECT_SETTING_request_t;

#define MSP_SELECT_SETTING_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP_SELECT_SETTING.

// MSP_SET_HEAD
// Sets the target heading for the heading hold controller (e.g., during MAG mode).
// Notes: Expects 2 bytes. Calls `updateHeadingHoldTarget()`.
typedef struct MSP_PACKED {
    int16_t heading; // Target heading (0-359).
} msp_MSP_SET_HEAD_request_t;

#define MSP_SET_HEAD_REQUEST_PAYLOAD_SIZE 2

// No reply payload for MSP_SET_HEAD.

// MSP_SET_SERVO_CONFIGURATION
// Sets the configuration for a single servo (legacy format).
// Notes: Expects 15 bytes. Returns error if index is invalid. Calls `servoComputeScalingFactors()`. Superseded by `MSP2_INAV_SET_SERVO_CONFIG`.
typedef struct MSP_PACKED {
    uint8_t servoIndex; // Index of the servo to configure (0 to `MAX_SUPPORTED_SERVOS - 1`).
    uint16_t min; // Minimum servo endpoint.
    uint16_t max; // Maximum servo endpoint.
    uint16_t middle; // Middle/Neutral servo position.
    uint8_t rate; // Servo rate/scaling.
    uint8_t reserved1; // Ignored.
    uint8_t reserved2; // Ignored.
    uint8_t legacyForwardChan; // Ignored.
    uint32_t legacyReversedSources; // Ignored.
} msp_MSP_SET_SERVO_CONFIGURATION_request_t;

#define MSP_SET_SERVO_CONFIGURATION_REQUEST_PAYLOAD_SIZE 15

// No reply payload for MSP_SET_SERVO_CONFIGURATION.

// MSP_SET_MOTOR
// Sets the disarmed motor values, typically used for motor testing or propeller balancing functions in a configurator.
// Notes: Expects 16 bytes. Modifies the `motor_disarmed` array. These values are *not* saved persistently.
typedef struct MSP_PACKED {
    uint16_t[8] motorValues; // Array of motor values to set when disarmed. Only affects first `MAX_SUPPORTED_MOTORS`.
} msp_MSP_SET_MOTOR_request_t;

// #define MSP_SET_MOTOR_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP_SET_MOTOR.

// MSP_SET_NAV_CONFIG
// No request payload for MSP_SET_NAV_CONFIG.

// No reply payload for MSP_SET_NAV_CONFIG.

// MSP_SET_3D
// Sets parameters related to 3D/reversible motor operation.
// Notes: Expects 6 bytes. Requires reversible motor support.
typedef struct MSP_PACKED {
    uint16_t deadbandLow; // Sets `reversibleMotorsConfigMutable()->deadband_low`.
    uint16_t deadbandHigh; // Sets `reversibleMotorsConfigMutable()->deadband_high`.
    uint16_t neutral; // Sets `reversibleMotorsConfigMutable()->neutral`.
} msp_MSP_SET_3D_request_t;

#define MSP_SET_3D_REQUEST_PAYLOAD_SIZE 6

// No reply payload for MSP_SET_3D.

// MSP_SET_RC_DEADBAND
// Sets RC input deadband values.
// Notes: Expects 5 bytes.
typedef struct MSP_PACKED {
    uint8_t deadband; // Sets `rcControlsConfigMutable()->deadband`.
    uint8_t yawDeadband; // Sets `rcControlsConfigMutable()->yaw_deadband`.
    uint8_t altHoldDeadband; // Sets `rcControlsConfigMutable()->alt_hold_deadband`.
    uint16_t throttleDeadband; // Sets `rcControlsConfigMutable()->mid_throttle_deadband`.
} msp_MSP_SET_RC_DEADBAND_request_t;

#define MSP_SET_RC_DEADBAND_REQUEST_PAYLOAD_SIZE 5

// No reply payload for MSP_SET_RC_DEADBAND.

// MSP_SET_RESET_CURR_PID
// Resets the PIDs of the *current* profile to their default values. Does not save.
// Notes: Calls `PG_RESET_CURRENT(pidProfile)`. To save, follow with `MSP_EEPROM_WRITE`.
// No request payload for MSP_SET_RESET_CURR_PID.

// No reply payload for MSP_SET_RESET_CURR_PID.

// MSP_SET_SENSOR_ALIGNMENT
// Sets sensor alignment (legacy format).
// Notes: Expects 4 bytes. Use `MSP_SET_BOARD_ALIGNMENT` for primary board orientation.
typedef struct MSP_PACKED {
    uint8_t gyroAlign; // Ignored.
    uint8_t accAlign; // Ignored.
    uint8_t magAlign; // Sets `compassConfigMutable()->mag_align` (if `USE_MAG`).
    uint8_t opflowAlign; // Sets `opticalFlowConfigMutable()->opflow_align` (if `USE_OPFLOW`).
} msp_MSP_SET_SENSOR_ALIGNMENT_request_t;

#define MSP_SET_SENSOR_ALIGNMENT_REQUEST_PAYLOAD_SIZE 4

// No reply payload for MSP_SET_SENSOR_ALIGNMENT.

// MSP_SET_LED_STRIP_MODECOLOR
// Sets the color index for a specific LED mode/function combination.
// Notes: Only available if `USE_LED_STRIP` is defined. Expects 3 bytes. Returns error if setting fails (invalid index).
typedef struct MSP_PACKED {
    uint8_t modeIndex; // Index of the LED mode (`ledModeIndex_e` or `LED_MODE_COUNT` for special).
    uint8_t directionOrSpecialIndex; // Index of the direction or special color.
    uint8_t colorIndex; // Index of the color to assign from `ledStripConfig()->colors`.
} msp_MSP_SET_LED_STRIP_MODECOLOR_request_t;

#define MSP_SET_LED_STRIP_MODECOLOR_REQUEST_PAYLOAD_SIZE 3

// No reply payload for MSP_SET_LED_STRIP_MODECOLOR.

// MSP_SET_ACC_TRIM
// Sets the accelerometer trim values (leveling calibration).
// Notes: Not implemented in INAV `fc_msp.c`. Use `MSP_ACC_CALIBRATION`.
// No request payload for MSP_SET_ACC_TRIM.

// No reply payload for MSP_SET_ACC_TRIM.

// MSP_ACC_TRIM
// Gets the accelerometer trim values.
// Notes: Not implemented in INAV `fc_msp.c`. Calibration data via `MSP_CALIBRATION_DATA`.
// No request payload for MSP_ACC_TRIM.

// No reply payload for MSP_ACC_TRIM.

// MSP_SERVO_MIX_RULES
// Retrieves the custom servo mixer rules (legacy format).
// Notes: Superseded by `MSP2_INAV_SERVO_MIXER`.
// No request payload for MSP_SERVO_MIX_RULES.

typedef struct MSP_PACKED {
    uint8_t targetChannel; // Servo output channel index (0-based).
    uint8_t inputSource; // Input source for the mix (RC chan, Roll, Pitch...). See `mixerSource_t`.
    uint16_t rate; // Mixing rate/weight. Needs scaling check.
    uint8_t speed; // Speed/Slew rate limit.
    uint8_t reserved1; // Always 0.
    uint8_t legacyMax; // Always 100 (Legacy).
    uint8_t legacyBox; // Always 0 (Legacy).
} msp_MSP_SERVO_MIX_RULES_reply_t;

#define MSP_SERVO_MIX_RULES_REPLY_PAYLOAD_SIZE 8

// MSP_SET_SERVO_MIX_RULE
// Sets a single custom servo mixer rule (legacy format).
// Notes: Expects 9 bytes. Returns error if index invalid. Calls `loadCustomServoMixer()`. Superseded by `MSP2_INAV_SET_SERVO_MIXER`.
typedef struct MSP_PACKED {
    uint8_t ruleIndex; // Index of the rule to set (0 to `MAX_SERVO_RULES - 1`).
    uint8_t targetChannel; // Servo output channel index.
    uint8_t inputSource; // Input source for the mix.
    uint16_t rate; // Mixing rate/weight.
    uint8_t speed; // Speed/Slew rate limit.
    uint16_t legacyMinMax; // Ignored.
    uint8_t legacyBox; // Ignored.
} msp_MSP_SET_SERVO_MIX_RULE_request_t;

#define MSP_SET_SERVO_MIX_RULE_REQUEST_PAYLOAD_SIZE 9

// No reply payload for MSP_SET_SERVO_MIX_RULE.

// MSP_SET_PASSTHROUGH
// Enables serial passthrough mode to peripherals like ESCs (BLHeli 4-way) or other serial devices.
// Notes: If successful, sets `mspPostProcessFn` to the appropriate handler (`mspSerialPassthroughFn` or `esc4wayProcess`). This handler takes over the serial port after the reply is sent. Requires `USE_SERIAL_4WAY_BLHELI_INTERFACE` for ESC passthrough.
// No request payload for MSP_SET_PASSTHROUGH.

typedef struct MSP_PACKED {
    uint8_t status; // 1 if passthrough started successfully, 0 on error (e.g., port not found). For 4way, returns number of ESCs found.
} msp_MSP_SET_PASSTHROUGH_reply_t;

#define MSP_SET_PASSTHROUGH_REPLY_PAYLOAD_SIZE 1

// MSP_RTC
// Retrieves the current Real-Time Clock time.
// Notes: Requires RTC hardware/support. Returns (0, 0) if time is not available/set.
// No request payload for MSP_RTC.

typedef struct MSP_PACKED {
    int32_t seconds; // Seconds since epoch (or relative time if not set). 0 if RTC time unknown.
    uint16_t millis; // Millisecond part of the time. 0 if RTC time unknown.
} msp_MSP_RTC_reply_t;

#define MSP_RTC_REPLY_PAYLOAD_SIZE 6

// MSP_SET_RTC
// Sets the Real-Time Clock time.
// Notes: Requires RTC hardware/support. Expects 6 bytes. Uses `rtcSet()`.
typedef struct MSP_PACKED {
    int32_t seconds; // Seconds component of time to set.
    uint16_t millis; // Millisecond component of time to set.
} msp_MSP_SET_RTC_request_t;

#define MSP_SET_RTC_REQUEST_PAYLOAD_SIZE 6

// No reply payload for MSP_SET_RTC.

// MSP_EEPROM_WRITE
// Saves the current configuration from RAM to non-volatile memory (EEPROM/Flash).
// Notes: Will fail if armed. Suspends RX, calls `writeEEPROM()`, `readEEPROM()`, resumes RX.
// No request payload for MSP_EEPROM_WRITE.

// No reply payload for MSP_EEPROM_WRITE.

// MSP_DEBUGMSG
// Retrieves debug ("serial printf") messages from the firmware.
// No request payload for MSP_DEBUGMSG.

typedef struct MSP_PACKED {
    char Message_Text[]; // NUL` terminated [debug message](https://github.com/iNavFlight/inav/blob/master/docs/development/serial_printf_debugging.md) text.
} msp_MSP_DEBUGMSG_reply_t;

// #define MSP_DEBUGMSG_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_DEBUG
// Retrieves values from the firmware's `debug[]` array (legacy 16-bit version).
// Notes: Useful for developers. See `MSP2_INAV_DEBUG` for 32-bit values.
// No request payload for MSP_DEBUG.

typedef struct MSP_PACKED {
    uint16_t[4] debugValues; // First 4 values from the `debug` array.
} msp_MSP_DEBUG_reply_t;

// #define MSP_DEBUG_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP_V2_FRAME
// This ID is used as a *payload indicator* within an MSPv1 message structure (`$M>`) to signify that the following payload conforms to the MSPv2 format. It's not a command itself.
// Notes: See MSPv2 documentation for the actual frame structure that follows this indicator.
// No request payload for MSP_V2_FRAME.

// No reply payload for MSP_V2_FRAME.

// MSP2_COMMON_TZ
// Gets the time zone offset configuration.
// No request payload for MSP2_COMMON_TZ.

typedef struct MSP_PACKED {
    int16_t tzOffsetMinutes; // Time zone offset from UTC (`timeConfig()->tz_offset`).
    uint8_t tzAutoDst; // Automatic daylight saving time enabled (`timeConfig()->tz_automatic_dst`).
} msp_MSP2_COMMON_TZ_reply_t;

#define MSP2_COMMON_TZ_REPLY_PAYLOAD_SIZE 3

// MSP2_COMMON_SET_TZ
// Sets the time zone offset configuration.
// Notes: Accepts 2 or 3 bytes.
// No request payload for MSP2_COMMON_SET_TZ.

// No reply payload for MSP2_COMMON_SET_TZ.

// MSP2_COMMON_SETTING
// Gets the value of a specific configuration setting, identified by name or index.
// Notes: Returns error if setting not found. Use `MSP2_COMMON_SETTING_INFO` to discover settings, types, and sizes.
typedef struct MSP_PACKED {
    char settingName[]; // Null-terminated string containing the setting name (e.g., "gyro_main_lpf_hz").
} msp_MSP2_COMMON_SETTING_request_t;

// #define MSP2_COMMON_SETTING_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

typedef struct MSP_PACKED {
    uint8_t[] settingValue; // Raw byte value of the setting. Size depends on the setting's type (`settingGetValueSize()`).
} msp_MSP2_COMMON_SETTING_reply_t;

// #define MSP2_COMMON_SETTING_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_COMMON_SET_SETTING
// Sets the value of a specific configuration setting, identified by name or index.
// Notes: Performs type checking and range validation (min/max). Returns error if setting not found, value size mismatch, or value out of range. Handles different data types (`uint8`, `int16`, `float`, `string`, etc.) internally.
typedef struct MSP_PACKED {
    Varies settingIdentifier; // Setting name (null-terminated string) OR Index (0x00 followed by `uint16_t` index).
    uint8_t[] settingValue; // Raw byte value to set for the setting. Size must match the setting's type.
} msp_MSP2_COMMON_SET_SETTING_request_t;

// #define MSP2_COMMON_SET_SETTING_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP2_COMMON_SET_SETTING.

// MSP2_COMMON_MOTOR_MIXER
// Retrieves the current motor mixer configuration (throttle, roll, pitch, yaw weights for each motor) for the primary and secondary mixer profiles.
// Notes: Scaling is `(float_weight + 2.0) * 1000`. `primaryMotorMixer()` provides the data.
// No request payload for MSP2_COMMON_MOTOR_MIXER.

// No reply payload for MSP2_COMMON_MOTOR_MIXER.

// MSP2_COMMON_SET_MOTOR_MIXER
// Sets the motor mixer weights for a single motor in the primary mixer profile.
// Notes: Expects 9 bytes. Modifies `primaryMotorMixerMutable()`. Returns error if index is invalid.
typedef struct MSP_PACKED {
    uint8_t motorIndex; // Index of the motor to configure (0 to `MAX_SUPPORTED_MOTORS - 1`).
    uint16_t throttleWeight; // Sets throttle weight from `(value / 1000.0) - 2.0`.
    uint16_t rollWeight; // Sets roll weight from `(value / 1000.0) - 2.0`.
    uint16_t pitchWeight; // Sets pitch weight from `(value / 1000.0) - 2.0`.
    uint16_t yawWeight; // Sets yaw weight from `(value / 1000.0) - 2.0`.
} msp_MSP2_COMMON_SET_MOTOR_MIXER_request_t;

#define MSP2_COMMON_SET_MOTOR_MIXER_REQUEST_PAYLOAD_SIZE 9

// No reply payload for MSP2_COMMON_SET_MOTOR_MIXER.

// MSP2_COMMON_SETTING_INFO
// Gets detailed information about a specific configuration setting (name, type, range, flags, current value, etc.).
// No request payload for MSP2_COMMON_SETTING_INFO.

typedef struct MSP_PACKED {
    char settingName[1]; // FLEX NOT LAST. Real field is variable length.
    // Null-terminated setting name.
    uint16_t pgn; // Parameter Group Number (PGN) ID.
    uint8_t type; // Variable type (`VAR_UINT8`, `VAR_FLOAT`, etc.).
    uint8_t section; // Setting section (`MASTER_VALUE`, `PROFILE_VALUE`, etc.).
    uint8_t mode; // Setting mode (`MODE_NORMAL`, `MODE_LOOKUP`, etc.).
    int32_t minValue; // Minimum allowed value (as signed 32-bit).
    uint32_t maxValue; // Maximum allowed value (as unsigned 32-bit).
    uint16_t settingIndex; // Absolute index of the setting.
    uint8_t profileIndex; // Current profile index (if applicable, else 0).
    uint8_t profileCount; // Total number of profiles (if applicable, else 0).
    char lookupNames[1]; // FLEX NOT LAST. Real field is variable length.
    // (If `mode == MODE_LOOKUP`) Series of null-terminated strings for each possible value from min to max.
    uint8_t[] settingValue; // Current raw byte value of the setting.
} msp_MSP2_COMMON_SETTING_INFO_reply_t;

// #define MSP2_COMMON_SETTING_INFO_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_COMMON_PG_LIST
// Gets a list of Parameter Group Numbers (PGNs) used by settings, along with the start and end setting indexes for each group. Can request info for a single PGN.
// Notes: Allows efficient fetching of related settings by group.
typedef struct MSP_PACKED {
    uint16_t pgn; // PGN ID to query. If omitted, returns all used PGNs.
} msp_MSP2_COMMON_PG_LIST_request_t;

#define MSP2_COMMON_PG_LIST_REQUEST_PAYLOAD_SIZE 2

typedef struct MSP_PACKED {
    uint16_t pgn; // Parameter Group Number (PGN) ID.
    uint16_t startIndex; // Absolute index of the first setting in this group.
    uint16_t endIndex; // Absolute index of the last setting in this group.
} msp_MSP2_COMMON_PG_LIST_reply_t;

#define MSP2_COMMON_PG_LIST_REPLY_PAYLOAD_SIZE 6

// MSP2_COMMON_SERIAL_CONFIG
// Retrieves the configuration for all available serial ports.
// Notes: Baud rate indexes map to actual baud rates (e.g., 9600, 115200). See `baudRates` array.
// No request payload for MSP2_COMMON_SERIAL_CONFIG.

typedef struct MSP_PACKED {
    uint8_t identifier; // Port identifier (`serialPortIdentifier_e`).
    uint32_t functionMask; // Bitmask of enabled functions (`FUNCTION_*`).
    uint8_t mspBaudIndex; // Baud rate index for MSP function.
    uint8_t gpsBaudIndex; // Baud rate index for GPS function.
    uint8_t telemetryBaudIndex; // Baud rate index for Telemetry function.
    uint8_t peripheralBaudIndex; // Baud rate index for other peripheral functions.
} msp_MSP2_COMMON_SERIAL_CONFIG_reply_t;

#define MSP2_COMMON_SERIAL_CONFIG_REPLY_PAYLOAD_SIZE 9

// MSP2_COMMON_SET_SERIAL_CONFIG
// Sets the configuration for one or more serial ports.
// Notes: Payload size must be a multiple of the size of one port config entry (1 + 4 + 4 = 9 bytes). Returns error if identifier is invalid or size is incorrect. Baud rate indexes are constrained `BAUD_MIN` to `BAUD_MAX`.
typedef struct MSP_PACKED {
    uint8_t identifier; // Port identifier (`serialPortIdentifier_e`).
    uint32_t functionMask; // Bitmask of functions to enable.
    uint8_t mspBaudIndex; // Baud rate index for MSP.
    uint8_t gpsBaudIndex; // Baud rate index for GPS.
    uint8_t telemetryBaudIndex; // Baud rate index for Telemetry.
    uint8_t peripheralBaudIndex; // Baud rate index for peripherals.
} msp_MSP2_COMMON_SET_SERIAL_CONFIG_request_t;

#define MSP2_COMMON_SET_SERIAL_CONFIG_REQUEST_PAYLOAD_SIZE 9

// No reply payload for MSP2_COMMON_SET_SERIAL_CONFIG.

// MSP2_COMMON_SET_RADAR_POS
// Sets the position and status information for a "radar" Point of Interest (POI). Used for displaying other craft/objects on the OSD map.
// Notes: Expects 19 bytes. Updates the `radar_pois` array.
typedef struct MSP_PACKED {
    uint8_t poiIndex; // Index of the POI slot (0 to `RADAR_MAX_POIS - 1`).
    uint8_t state; // Status of the POI (0=undefined, 1=armed, 2=lost).
    int32_t latitude; // Latitude of the POI.
    int32_t longitude; // Longitude of the POI.
    int32_t altitude; // Altitude of the POI.
    int16_t heading; // Heading of the POI.
    uint16_t speed; // Speed of the POI.
    uint8_t linkQuality; // Link quality indicator.
} msp_MSP2_COMMON_SET_RADAR_POS_request_t;

#define MSP2_COMMON_SET_RADAR_POS_REQUEST_PAYLOAD_SIZE 19

// No reply payload for MSP2_COMMON_SET_RADAR_POS.

// MSP2_COMMON_SET_RADAR_ITD
// Sets radar information to display (likely internal/unused).
// Notes: Not implemented in INAV `fc_msp.c`.
// No request payload for MSP2_COMMON_SET_RADAR_ITD.

// No reply payload for MSP2_COMMON_SET_RADAR_ITD.

// MSP2_COMMON_SET_MSP_RC_LINK_STATS
// Provides RC link statistics (RSSI, LQ) to the FC, typically from an MSP-based RC link (like ExpressLRS). Sent periodically by the RC link.
// Notes: Requires `USE_RX_MSP`. Expects at least 7 bytes. Updates `rxLinkStatistics` and sets RSSI via `setRSSIFromMSP_RC()` only if `sublinkID` is 0. This message expects **no reply** (`MSP_RESULT_NO_REPLY`).
typedef struct MSP_PACKED {
    uint8_t sublinkID; // Sublink identifier (usually 0).
    uint8_t validLink; // Indicates if the link is currently valid (not in failsafe).
    uint8_t rssiPercent; // Uplink RSSI percentage (0-100).
    uint8_t uplinkRSSI_dBm; // Uplink RSSI in dBm (sent as positive, e.g., 70 means -70dBm).
    uint8_t downlinkLQ; // Downlink Link Quality (0-100).
    uint8_t uplinkLQ; // Uplink Link Quality (0-100).
    int8_t uplinkSNR; // Uplink Signal-to-Noise Ratio.
} msp_MSP2_COMMON_SET_MSP_RC_LINK_STATS_request_t;

#define MSP2_COMMON_SET_MSP_RC_LINK_STATS_REQUEST_PAYLOAD_SIZE 7

// No reply payload for MSP2_COMMON_SET_MSP_RC_LINK_STATS.

// MSP2_COMMON_SET_MSP_RC_INFO
// Provides additional RC link information (power levels, band, mode) to the FC from an MSP-based RC link. Sent less frequently than link stats.
// Notes: Requires `USE_RX_MSP`. Expects at least 15 bytes. Updates `rxLinkStatistics` only if `sublinkID` is 0. Converts band/mode strings to uppercase. This message expects **no reply** (`MSP_RESULT_NO_REPLY`).
typedef struct MSP_PACKED {
    uint8_t sublinkID; // Sublink identifier (usually 0).
    uint16_t uplinkTxPower; // Uplink transmitter power level.
    uint16_t downlinkTxPower; // Downlink transmitter power level.
    char band[4]; // Operating band string (e.g., "2G4", "900").
    char mode[6]; // Operating mode/rate string (e.g., "100HZ", "F1000").
} msp_MSP2_COMMON_SET_MSP_RC_INFO_request_t;

#define MSP2_COMMON_SET_MSP_RC_INFO_REQUEST_PAYLOAD_SIZE 15

// No reply payload for MSP2_COMMON_SET_MSP_RC_INFO.

// MSP2_SENSOR_RANGEFINDER
// Provides rangefinder data (distance, quality) from an external MSP-based sensor.
// Notes: Requires `USE_RANGEFINDER_MSP`. Calls `mspRangefinderReceiveNewData()`.
typedef struct MSP_PACKED {
    uint8_t quality; // Quality of the measurement.
    int32_t distanceMm; // Measured distance. Negative value indicates out of range.
} msp_MSP2_SENSOR_RANGEFINDER_request_t;

#define MSP2_SENSOR_RANGEFINDER_REQUEST_PAYLOAD_SIZE 5

// No reply payload for MSP2_SENSOR_RANGEFINDER.

// MSP2_SENSOR_OPTIC_FLOW
// Provides optical flow data (motion, quality) from an external MSP-based sensor.
// Notes: Requires `USE_OPFLOW_MSP`. Calls `mspOpflowReceiveNewData()`.
typedef struct MSP_PACKED {
    uint8_t quality; // Quality of the measurement (0-255).
    int32_t motionX; // Raw integrated flow value X.
    int32_t motionY; // Raw integrated flow value Y.
} msp_MSP2_SENSOR_OPTIC_FLOW_request_t;

#define MSP2_SENSOR_OPTIC_FLOW_REQUEST_PAYLOAD_SIZE 9

// No reply payload for MSP2_SENSOR_OPTIC_FLOW.

// MSP2_SENSOR_GPS
// Provides detailed GPS data from an external MSP-based GPS module.
// Notes: Requires `USE_GPS_PROTO_MSP`. Calls `mspGPSReceiveNewData()`.
typedef struct MSP_PACKED {
    uint8_t instance; // Sensor instance number (for multi-GPS).
    uint16_t gpsWeek; // GPS week number (0xFFFF if unavailable).
    uint32_t msTOW; // Milliseconds Time of Week.
    uint8_t fixType; // Type of GPS fix.
    uint8_t satellitesInView; // Number of satellites used in solution.
    uint16_t hPosAccuracy; // Horizontal position accuracy estimate.
    uint16_t vPosAccuracy; // Vertical position accuracy estimate.
    uint16_t hVelAccuracy; // Horizontal velocity accuracy estimate.
    uint16_t hdop; // Horizontal Dilution of Precision.
    int32_t longitude; // Longitude.
    int32_t latitude; // Latitude.
    int32_t mslAltitude; // Altitude above Mean Sea Level.
    int32_t nedVelNorth; // North velocity (NED frame).
    int32_t nedVelEast; // East velocity (NED frame).
    int32_t nedVelDown; // Down velocity (NED frame).
    uint16_t groundCourse; // Ground course (0-36000).
    uint16_t trueYaw; // True heading/yaw (0-36000, 65535 if unavailable).
    uint16_t year; // Year (e.g., 2023).
    uint8_t month; // Month (1-12).
    uint8_t day; // Day of month (1-31).
    uint8_t hour; // Hour (0-23).
    uint8_t min; // Minute (0-59).
    uint8_t sec; // Second (0-59).
} msp_MSP2_SENSOR_GPS_request_t;

#define MSP2_SENSOR_GPS_REQUEST_PAYLOAD_SIZE 52

// No reply payload for MSP2_SENSOR_GPS.

// MSP2_SENSOR_COMPASS
// Provides magnetometer data from an external MSP-based compass module.
// Notes: Requires `USE_MAG_MSP`. Calls `mspMagReceiveNewData()`.
typedef struct MSP_PACKED {
    uint8_t instance; // Sensor instance number.
    uint32_t timeMs; // Timestamp from the sensor.
    int16_t magX; // Front component reading.
    int16_t magY; // Right component reading.
    int16_t magZ; // Down component reading.
} msp_MSP2_SENSOR_COMPASS_request_t;

#define MSP2_SENSOR_COMPASS_REQUEST_PAYLOAD_SIZE 11

// No reply payload for MSP2_SENSOR_COMPASS.

// MSP2_SENSOR_BAROMETER
// Provides barometer data from an external MSP-based barometer module.
// Notes: Requires `USE_BARO_MSP`. Calls `mspBaroReceiveNewData()`.
typedef struct MSP_PACKED {
    uint8_t instance; // Sensor instance number.
    uint32_t timeMs; // Timestamp from the sensor.
    float pressurePa; // Absolute pressure.
    int16_t temp; // Temperature.
} msp_MSP2_SENSOR_BAROMETER_request_t;

#define MSP2_SENSOR_BAROMETER_REQUEST_PAYLOAD_SIZE 11

// No reply payload for MSP2_SENSOR_BAROMETER.

// MSP2_SENSOR_AIRSPEED
// Provides airspeed data from an external MSP-based pitot sensor module.
// Notes: Requires `USE_PITOT_MSP`. Calls `mspPitotmeterReceiveNewData()`.
typedef struct MSP_PACKED {
    uint8_t instance; // Sensor instance number.
    uint32_t timeMs; // Timestamp from the sensor.
    float diffPressurePa; // Differential pressure.
    int16_t temp; // Temperature.
} msp_MSP2_SENSOR_AIRSPEED_request_t;

#define MSP2_SENSOR_AIRSPEED_REQUEST_PAYLOAD_SIZE 11

// No reply payload for MSP2_SENSOR_AIRSPEED.

// MSP2_SENSOR_HEADTRACKER
// Provides head tracker orientation data.
// Notes: Requires `USE_HEADTRACKER` and `USE_HEADTRACKER_MSP`. Calls `mspHeadTrackerReceiverNewData()`. Payload structure needs verification from `mspHeadTrackerReceiverNewData` implementation.
typedef struct MSP_PACKED {
    Varies ___; 
} msp_MSP2_SENSOR_HEADTRACKER_request_t;

// #define MSP2_SENSOR_HEADTRACKER_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP2_SENSOR_HEADTRACKER.

// MSP2_INAV_STATUS
// Provides comprehensive flight controller status, extending `MSP_STATUS_EX` with full arming flags, battery profile, and mixer profile.
// No request payload for MSP2_INAV_STATUS.

typedef struct MSP_PACKED {
    uint16_t cycleTime; // Main loop cycle time.
    uint16_t i2cErrors; // I2C errors.
    uint16_t sensorStatus; // Sensor status bitmask.
    uint16_t cpuLoad; // Average system load percentage.
    uint8_t profileAndBattProfile; // Bits 0-3: Config profile index (`getConfigProfile()`), Bits 4-7: Battery profile index (`getConfigBatteryProfile()`).
    uint32_t armingFlags; // Full 32-bit flight controller arming flags (`armingFlags`).
    boxBitmask_t activeModes; // Full bitmask of active flight modes (`packBoxModeFlags()`).
    uint8_t mixerProfile; // Current mixer profile index (`getConfigMixerProfile()`).
} msp_MSP2_INAV_STATUS_reply_t;

// #define MSP2_INAV_STATUS_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_INAV_OPTICAL_FLOW
// Provides data from the optical flow sensor.
// Notes: Requires `USE_OPFLOW`.
// No request payload for MSP2_INAV_OPTICAL_FLOW.

typedef struct MSP_PACKED {
    uint8_t quality; // Raw quality indicator from the sensor (`opflow.rawQuality`). 0 if `USE_OPFLOW` disabled.
    int16_t flowRateX; // Optical flow rate X (roll axis) (`RADIANS_TO_DEGREES(opflow.flowRate[X])`). 0 if `USE_OPFLOW` disabled.
    int16_t flowRateY; // Optical flow rate Y (pitch axis) (`RADIANS_TO_DEGREES(opflow.flowRate[Y])`). 0 if `USE_OPFLOW` disabled.
    int16_t bodyRateX; // Compensated body rate X (roll axis) (`RADIANS_TO_DEGREES(opflow.bodyRate[X])`). 0 if `USE_OPFLOW` disabled.
    int16_t bodyRateY; // Compensated body rate Y (pitch axis) (`RADIANS_TO_DEGREES(opflow.bodyRate[Y])`). 0 if `USE_OPFLOW` disabled.
} msp_MSP2_INAV_OPTICAL_FLOW_reply_t;

#define MSP2_INAV_OPTICAL_FLOW_REPLY_PAYLOAD_SIZE 9

// MSP2_INAV_ANALOG
// Provides detailed analog sensor readings, superseding `MSP_ANALOG` with higher precision and additional fields.
// No request payload for MSP2_INAV_ANALOG.

typedef struct MSP_PACKED {
    getBatteryState() batteryFlags; // Battery status flags: Bit 0=Full on plug-in, Bit 1=Use capacity threshold, Bit 2-3=Battery State enum (`getBatteryState()`), Bit 4-7=Cell Count (`getBatteryCellCount()`).
    uint16_t vbat; // Battery voltage (`getBatteryVoltage()`).
    uint16_t amperage; // Current draw (`getAmperage()`).
    uint32_t powerDraw; // Power draw (`getPower()`).
    uint32_t mAhDrawn; // Consumed capacity (`getMAhDrawn()`).
    uint32_t mWhDrawn; // Consumed energy (`getMWhDrawn()`).
    uint32_t remainingCapacity; // Estimated remaining capacity (`getBatteryRemainingCapacity()`).
    uint8_t percentageRemaining; // Estimated remaining capacity percentage (`calculateBatteryPercentage()`).
    uint16_t rssi; // RSSI value (`getRSSI()`).
} msp_MSP2_INAV_ANALOG_reply_t;

#define MSP2_INAV_ANALOG_REPLY_PAYLOAD_SIZE 24

// MSP2_INAV_MISC
// Retrieves miscellaneous configuration settings, superseding `MSP_MISC` with higher precision and capacity fields.
// No request payload for MSP2_INAV_MISC.

typedef struct MSP_PACKED {
    uint16_t midRc; // Mid RC value (`PWM_RANGE_MIDDLE`).
    uint16_t legacyMinThrottle; // Always 0 (Legacy).
    uint16_t maxThrottle; // Maximum throttle command (`getMaxThrottle()`).
    uint16_t minCommand; // Minimum motor command (`motorConfig()->mincommand`).
    uint16_t failsafeThrottle; // Failsafe throttle level (`currentBatteryProfile->failsafe_throttle`).
    uint8_t gpsType; // GPS provider type (`gpsConfig()->provider`). 0 if `USE_GPS` disabled.
    uint8_t legacyGpsBaud; // Always 0 (Legacy).
    uint8_t gpsSbasMode; // GPS SBAS mode (`gpsConfig()->sbasMode`). 0 if `USE_GPS` disabled.
    uint8_t rssiChannel; // RSSI channel index (1-based) (`rxConfig()->rssi_channel`).
    uint16_t magDeclination; // Magnetic declination / 10 (`compassConfig()->mag_declination / 10`). 0 if `USE_MAG` disabled.
    uint16_t vbatScale; // Voltage scale (`batteryMetersConfig()->voltage.scale`). 0 if `USE_ADC` disabled.
    uint8_t vbatSource; // Voltage source (`batteryMetersConfig()->voltageSource`). 0 if `USE_ADC` disabled.
    uint8_t cellCount; // Configured cell count (`currentBatteryProfile->cells`). 0 if `USE_ADC` disabled.
    uint16_t vbatCellDetect; // Cell detection voltage (`currentBatteryProfile->voltage.cellDetect`). 0 if `USE_ADC` disabled.
    uint16_t vbatMinCell; // Min cell voltage (`currentBatteryProfile->voltage.cellMin`). 0 if `USE_ADC` disabled.
    uint16_t vbatMaxCell; // Max cell voltage (`currentBatteryProfile->voltage.cellMax`). 0 if `USE_ADC` disabled.
    uint16_t vbatWarningCell; // Warning cell voltage (`currentBatteryProfile->voltage.cellWarning`). 0 if `USE_ADC` disabled.
    uint32_t capacityValue; // Battery capacity (`currentBatteryProfile->capacity.value`).
    uint32_t capacityWarning; // Capacity warning threshold (`currentBatteryProfile->capacity.warning`).
    uint32_t capacityCritical; // Capacity critical threshold (`currentBatteryProfile->capacity.critical`).
    uint8_t capacityUnit; // Capacity unit (`batteryMetersConfig()->capacity_unit`).
} msp_MSP2_INAV_MISC_reply_t;

#define MSP2_INAV_MISC_REPLY_PAYLOAD_SIZE 41

// MSP2_INAV_SET_MISC
// Sets miscellaneous configuration settings, superseding `MSP_SET_MISC`.
// Notes: Expects 41 bytes. Performs validation on `vbatSource` and `capacityUnit`.
typedef struct MSP_PACKED {
    uint16_t midRc; // Ignored.
    uint16_t legacyMinThrottle; // Ignored.
    uint16_t legacyMaxThrottle; // Ignored.
    uint16_t minCommand; // Sets `motorConfigMutable()->mincommand` (constrained).
    uint16_t failsafeThrottle; // Sets `currentBatteryProfileMutable->failsafe_throttle` (constrained).
    uint8_t gpsType; // Sets `gpsConfigMutable()->provider` (if `USE_GPS`).
    uint8_t legacyGpsBaud; // Ignored.
    uint8_t gpsSbasMode; // Sets `gpsConfigMutable()->sbasMode` (if `USE_GPS`).
    uint8_t rssiChannel; // Sets `rxConfigMutable()->rssi_channel` (constrained). Updates source.
    uint16_t magDeclination; // Sets `compassConfigMutable()->mag_declination = value * 10` (if `USE_MAG`).
    uint16_t vbatScale; // Sets `batteryMetersConfigMutable()->voltage.scale` (if `USE_ADC`).
    uint8_t vbatSource; // Sets `batteryMetersConfigMutable()->voltageSource` (if `USE_ADC`, validated).
    uint8_t cellCount; // Sets `currentBatteryProfileMutable->cells` (if `USE_ADC`).
    uint16_t vbatCellDetect; // Sets `currentBatteryProfileMutable->voltage.cellDetect` (if `USE_ADC`).
    uint16_t vbatMinCell; // Sets `currentBatteryProfileMutable->voltage.cellMin` (if `USE_ADC`).
    uint16_t vbatMaxCell; // Sets `currentBatteryProfileMutable->voltage.cellMax` (if `USE_ADC`).
    uint16_t vbatWarningCell; // Sets `currentBatteryProfileMutable->voltage.cellWarning` (if `USE_ADC`).
    uint32_t capacityValue; // Sets `currentBatteryProfileMutable->capacity.value`.
    uint32_t capacityWarning; // Sets `currentBatteryProfileMutable->capacity.warning`.
    uint32_t capacityCritical; // Sets `currentBatteryProfileMutable->capacity.critical`.
    uint8_t capacityUnit; // Sets `batteryMetersConfigMutable()->capacity_unit` (validated). Updates OSD energy unit if changed.
} msp_MSP2_INAV_SET_MISC_request_t;

#define MSP2_INAV_SET_MISC_REQUEST_PAYLOAD_SIZE 41

// No reply payload for MSP2_INAV_SET_MISC.

// MSP2_INAV_BATTERY_CONFIG
// Retrieves the configuration specific to the battery voltage and current sensors and capacity settings for the current battery profile.
// Notes: Fields are 0 if `USE_ADC` is not defined.
// No request payload for MSP2_INAV_BATTERY_CONFIG.

typedef struct MSP_PACKED {
    uint16_t vbatScale; // Voltage scale (`batteryMetersConfig()->voltage.scale`).
    uint8_t vbatSource; // Voltage source (`batteryMetersConfig()->voltageSource`).
    uint8_t cellCount; // Configured cell count (`currentBatteryProfile->cells`).
    uint16_t vbatCellDetect; // Cell detection voltage (`currentBatteryProfile->voltage.cellDetect`).
    uint16_t vbatMinCell; // Min cell voltage (`currentBatteryProfile->voltage.cellMin`).
    uint16_t vbatMaxCell; // Max cell voltage (`currentBatteryProfile->voltage.cellMax`).
    uint16_t vbatWarningCell; // Warning cell voltage (`currentBatteryProfile->voltage.cellWarning`).
    uint16_t currentOffset; // Current sensor offset (`batteryMetersConfig()->current.offset`).
    uint16_t currentScale; // Current sensor scale (`batteryMetersConfig()->current.scale`).
    uint32_t capacityValue; // Battery capacity (`currentBatteryProfile->capacity.value`).
    uint32_t capacityWarning; // Capacity warning threshold (`currentBatteryProfile->capacity.warning`).
    uint32_t capacityCritical; // Capacity critical threshold (`currentBatteryProfile->capacity.critical`).
    uint8_t capacityUnit; // Capacity unit (`batteryMetersConfig()->capacity_unit`).
} msp_MSP2_INAV_BATTERY_CONFIG_reply_t;

#define MSP2_INAV_BATTERY_CONFIG_REPLY_PAYLOAD_SIZE 29

// MSP2_INAV_SET_BATTERY_CONFIG
// Sets the battery voltage/current sensor configuration and capacity settings for the current battery profile.
// Notes: Expects 29 bytes. Performs validation on `vbatSource` and `capacityUnit`.
typedef struct MSP_PACKED {
    uint16_t vbatScale; // Sets `batteryMetersConfigMutable()->voltage.scale` (if `USE_ADC`).
    uint8_t vbatSource; // Sets `batteryMetersConfigMutable()->voltageSource` (if `USE_ADC`, validated).
    uint8_t cellCount; // Sets `currentBatteryProfileMutable->cells` (if `USE_ADC`).
    uint16_t vbatCellDetect; // Sets `currentBatteryProfileMutable->voltage.cellDetect` (if `USE_ADC`).
    uint16_t vbatMinCell; // Sets `currentBatteryProfileMutable->voltage.cellMin` (if `USE_ADC`).
    uint16_t vbatMaxCell; // Sets `currentBatteryProfileMutable->voltage.cellMax` (if `USE_ADC`).
    uint16_t vbatWarningCell; // Sets `currentBatteryProfileMutable->voltage.cellWarning` (if `USE_ADC`).
    uint16_t currentOffset; // Sets `batteryMetersConfigMutable()->current.offset`.
    uint16_t currentScale; // Sets `batteryMetersConfigMutable()->current.scale`.
    uint32_t capacityValue; // Sets `currentBatteryProfileMutable->capacity.value`.
    uint32_t capacityWarning; // Sets `currentBatteryProfileMutable->capacity.warning`.
    uint32_t capacityCritical; // Sets `currentBatteryProfileMutable->capacity.critical`.
    uint8_t capacityUnit; // Sets `batteryMetersConfigMutable()->capacity_unit` (validated). Updates OSD energy unit if changed.
} msp_MSP2_INAV_SET_BATTERY_CONFIG_request_t;

#define MSP2_INAV_SET_BATTERY_CONFIG_REQUEST_PAYLOAD_SIZE 29

// No reply payload for MSP2_INAV_SET_BATTERY_CONFIG.

// MSP2_INAV_RATE_PROFILE
// Retrieves the rates and expos for the current control rate profile, including both stabilized and manual flight modes. Supersedes `MSP_RC_TUNING`.
// No request payload for MSP2_INAV_RATE_PROFILE.

typedef struct MSP_PACKED {
    uint8_t throttleMid; // Throttle Midpoint (`currentControlRateProfile->throttle.rcMid8`).
    uint8_t throttleExpo; // Throttle Expo (`currentControlRateProfile->throttle.rcExpo8`).
    uint8_t dynamicThrottlePID; // TPA value (`currentControlRateProfile->throttle.dynPID`).
    uint16_t tpaBreakpoint; // TPA breakpoint (`currentControlRateProfile->throttle.pa_breakpoint`).
    uint8_t stabRcExpo; // Stabilized Roll/Pitch Expo (`currentControlRateProfile->stabilized.rcExpo8`).
    uint8_t stabRcYawExpo; // Stabilized Yaw Expo (`currentControlRateProfile->stabilized.rcYawExpo8`).
    uint8_t stabRollRate; // Stabilized Roll Rate (`currentControlRateProfile->stabilized.rates[FD_ROLL]`).
    uint8_t stabPitchRate; // Stabilized Pitch Rate (`currentControlRateProfile->stabilized.rates[FD_PITCH]`).
    uint8_t stabYawRate; // Stabilized Yaw Rate (`currentControlRateProfile->stabilized.rates[FD_YAW]`).
    uint8_t manualRcExpo; // Manual Roll/Pitch Expo (`currentControlRateProfile->manual.rcExpo8`).
    uint8_t manualRcYawExpo; // Manual Yaw Expo (`currentControlRateProfile->manual.rcYawExpo8`).
    uint8_t manualRollRate; // Manual Roll Rate (`currentControlRateProfile->manual.rates[FD_ROLL]`).
    uint8_t manualPitchRate; // Manual Pitch Rate (`currentControlRateProfile->manual.rates[FD_PITCH]`).
    uint8_t manualYawRate; // Manual Yaw Rate (`currentControlRateProfile->manual.rates[FD_YAW]`).
} msp_MSP2_INAV_RATE_PROFILE_reply_t;

#define MSP2_INAV_RATE_PROFILE_REPLY_PAYLOAD_SIZE 15

// MSP2_INAV_SET_RATE_PROFILE
// Sets the rates and expos for the current control rate profile (stabilized and manual). Supersedes `MSP_SET_RC_TUNING`.
// Notes: Expects 15 bytes. Constraints applied to rates based on axis.
typedef struct MSP_PACKED {
    uint8_t throttleMid; // Sets `currentControlRateProfile_p->throttle.rcMid8`.
    uint8_t throttleExpo; // Sets `currentControlRateProfile_p->throttle.rcExpo8`.
    uint8_t dynamicThrottlePID; // Sets `currentControlRateProfile_p->throttle.dynPID`.
    uint16_t tpaBreakpoint; // Sets `currentControlRateProfile_p->throttle.pa_breakpoint`.
    uint8_t stabRcExpo; // Sets `currentControlRateProfile_p->stabilized.rcExpo8`.
    uint8_t stabRcYawExpo; // Sets `currentControlRateProfile_p->stabilized.rcYawExpo8`.
    uint8_t stabRollRate; // Sets `currentControlRateProfile_p->stabilized.rates[FD_ROLL]` (constrained).
    uint8_t stabPitchRate; // Sets `currentControlRateProfile_p->stabilized.rates[FD_PITCH]` (constrained).
    uint8_t stabYawRate; // Sets `currentControlRateProfile_p->stabilized.rates[FD_YAW]` (constrained).
    uint8_t manualRcExpo; // Sets `currentControlRateProfile_p->manual.rcExpo8`.
    uint8_t manualRcYawExpo; // Sets `currentControlRateProfile_p->manual.rcYawExpo8`.
    uint8_t manualRollRate; // Sets `currentControlRateProfile_p->manual.rates[FD_ROLL]` (constrained).
    uint8_t manualPitchRate; // Sets `currentControlRateProfile_p->manual.rates[FD_PITCH]` (constrained).
    uint8_t manualYawRate; // Sets `currentControlRateProfile_p->manual.rates[FD_YAW]` (constrained).
} msp_MSP2_INAV_SET_RATE_PROFILE_request_t;

#define MSP2_INAV_SET_RATE_PROFILE_REQUEST_PAYLOAD_SIZE 15

// No reply payload for MSP2_INAV_SET_RATE_PROFILE.

// MSP2_INAV_AIR_SPEED
// Retrieves the estimated or measured airspeed.
// Notes: Requires `USE_PITOT` for measured airspeed. May return GPS ground speed if pitot unavailable but GPS is present and configured.
// No request payload for MSP2_INAV_AIR_SPEED.

typedef struct MSP_PACKED {
    uint32_t airspeed; // Estimated/measured airspeed (`getAirspeedEstimate()`). 0 if `USE_PITOT` disabled or no valid data.
} msp_MSP2_INAV_AIR_SPEED_reply_t;

#define MSP2_INAV_AIR_SPEED_REPLY_PAYLOAD_SIZE 4

// MSP2_INAV_OUTPUT_MAPPING
// Retrieves the output mapping configuration (identifies which timer outputs are used for Motors/Servos). Legacy version sending only 8-bit usage flags.
// Notes: Superseded by `MSP2_INAV_OUTPUT_MAPPING_EXT2`. Only includes timers *not* used for PPM/PWM input.
// No request payload for MSP2_INAV_OUTPUT_MAPPING.

typedef struct MSP_PACKED {
    uint8_t usageFlags; // Timer usage flags (truncated). `TIM_USE_MOTOR` or `TIM_USE_SERVO`.
} msp_MSP2_INAV_OUTPUT_MAPPING_reply_t;

#define MSP2_INAV_OUTPUT_MAPPING_REPLY_PAYLOAD_SIZE 1

// MSP2_INAV_MC_BRAKING
// Retrieves configuration parameters for the multirotor braking mode feature.
// Notes: Payload is empty if `USE_MR_BRAKING_MODE` is not defined.
// No request payload for MSP2_INAV_MC_BRAKING.

typedef struct MSP_PACKED {
    uint16_t brakingSpeedThreshold; // Speed above which braking engages (`navConfig()->mc.braking_speed_threshold`).
    uint16_t brakingDisengageSpeed; // Speed below which braking disengages (`navConfig()->mc.braking_disengage_speed`).
    uint16_t brakingTimeout; // Timeout before braking force reduces (`navConfig()->mc.braking_timeout`).
    uint8_t brakingBoostFactor; // Boost factor applied during braking (`navConfig()->mc.braking_boost_factor`).
    uint16_t brakingBoostTimeout; // Timeout for the boost factor (`navConfig()->mc.braking_boost_timeout`).
    uint16_t brakingBoostSpeedThreshold; // Speed threshold for boost engagement (`navConfig()->mc.braking_boost_speed_threshold`).
    uint16_t brakingBoostDisengageSpeed; // Speed threshold for boost disengagement (`navConfig()->mc.braking_boost_disengage_speed`).
    uint8_t brakingBankAngle; // Maximum bank angle allowed during braking (`navConfig()->mc.braking_bank_angle`).
} msp_MSP2_INAV_MC_BRAKING_reply_t;

#define MSP2_INAV_MC_BRAKING_REPLY_PAYLOAD_SIZE 14

// MSP2_INAV_SET_MC_BRAKING
// Sets configuration parameters for the multirotor braking mode feature.
// Notes: Expects 14 bytes. Returns error if `USE_MR_BRAKING_MODE` is not defined.
typedef struct MSP_PACKED {
    uint16_t brakingSpeedThreshold; // Sets `navConfigMutable()->mc.braking_speed_threshold`.
    uint16_t brakingDisengageSpeed; // Sets `navConfigMutable()->mc.braking_disengage_speed`.
    uint16_t brakingTimeout; // Sets `navConfigMutable()->mc.braking_timeout`.
    uint8_t brakingBoostFactor; // Sets `navConfigMutable()->mc.braking_boost_factor`.
    uint16_t brakingBoostTimeout; // Sets `navConfigMutable()->mc.braking_boost_timeout`.
    uint16_t brakingBoostSpeedThreshold; // Sets `navConfigMutable()->mc.braking_boost_speed_threshold`.
    uint16_t brakingBoostDisengageSpeed; // Sets `navConfigMutable()->mc.braking_boost_disengage_speed`.
    uint8_t brakingBankAngle; // Sets `navConfigMutable()->mc.braking_bank_angle`.
} msp_MSP2_INAV_SET_MC_BRAKING_request_t;

#define MSP2_INAV_SET_MC_BRAKING_REQUEST_PAYLOAD_SIZE 14

// No reply payload for MSP2_INAV_SET_MC_BRAKING.

// MSP2_INAV_OUTPUT_MAPPING_EXT
// Retrieves extended output mapping configuration (timer ID and usage flags). Obsolete, use `MSP2_INAV_OUTPUT_MAPPING_EXT2`.
// Notes: Usage flags are truncated to 8 bits. `timerId` mapping is target-specific.
// No request payload for MSP2_INAV_OUTPUT_MAPPING_EXT.

typedef struct MSP_PACKED {
    uint8_t timerId; // Hardware timer identifier (e.g., `TIM1`, `TIM2`). Value depends on target.
    uint8_t usageFlags; // Timer usage flags (truncated). `TIM_USE_MOTOR` or `TIM_USE_SERVO`.
} msp_MSP2_INAV_OUTPUT_MAPPING_EXT_reply_t;

#define MSP2_INAV_OUTPUT_MAPPING_EXT_REPLY_PAYLOAD_SIZE 2

// MSP2_INAV_TIMER_OUTPUT_MODE
// Get or list the output mode override for hardware timers (e.g., force ONESHOT, DSHOT).
// Notes: Only available on non-SITL builds. `HARDWARE_TIMER_DEFINITION_COUNT` varies by target.
// No request payload for MSP2_INAV_TIMER_OUTPUT_MODE.

typedef struct MSP_PACKED {
    uint8_t timerIndex; // Timer index.
    TIMER_OUTPUT_MODE_* outputMode; // Output mode override (`TIMER_OUTPUT_MODE_*` enum).
} msp_MSP2_INAV_TIMER_OUTPUT_MODE_reply_t;

#define MSP2_INAV_TIMER_OUTPUT_MODE_REPLY_PAYLOAD_SIZE 2

// MSP2_INAV_SET_TIMER_OUTPUT_MODE
// Set the output mode override for a specific hardware timer.
// Notes: Only available on non-SITL builds. Expects 2 bytes. Returns error if `timerIndex` is invalid.
typedef struct MSP_PACKED {
    uint8_t timerIndex; // Index of the hardware timer definition.
    TIMER_OUTPUT_MODE_* outputMode; // Output mode override (`TIMER_OUTPUT_MODE_*` enum) to set.
} msp_MSP2_INAV_SET_TIMER_OUTPUT_MODE_request_t;

#define MSP2_INAV_SET_TIMER_OUTPUT_MODE_REQUEST_PAYLOAD_SIZE 2

// No reply payload for MSP2_INAV_SET_TIMER_OUTPUT_MODE.

// MSP2_INAV_MIXER
// Retrieves INAV-specific mixer configuration details.
// No request payload for MSP2_INAV_MIXER.

typedef struct MSP_PACKED {
    uint8_t motorDirectionInverted; // Boolean: 1 if motor direction is reversed globally (`mixerConfig()->motorDirectionInverted`).
    uint8_t reserved1; // Always 0 (Was yaw jump prevention limit).
    uint8_t motorStopOnLow; // Boolean: 1 if motors stop at minimum throttle (`mixerConfig()->motorstopOnLow`).
    platformType_e platformType; // Enum (`platformType_e`): Vehicle platform type (Multirotor, Airplane, etc.) (`mixerConfig()->platformType`).
    uint8_t hasFlaps; // Boolean: 1 if the current mixer configuration includes flaps (`mixerConfig()->hasFlaps`).
    mixerPreset_e appliedMixerPreset; // Enum (`mixerPreset_e`): Mixer preset currently applied (`mixerConfig()->appliedMixerPreset`).
    uint8_t maxMotors; // Constant: Maximum motors supported (`MAX_SUPPORTED_MOTORS`).
    uint8_t maxServos; // Constant: Maximum servos supported (`MAX_SUPPORTED_SERVOS`).
} msp_MSP2_INAV_MIXER_reply_t;

#define MSP2_INAV_MIXER_REPLY_PAYLOAD_SIZE 9

// MSP2_INAV_SET_MIXER
// Sets INAV-specific mixer configuration details.
// Notes: Expects 9 bytes. Calls `mixerUpdateStateFlags()`.
typedef struct MSP_PACKED {
    uint8_t motorDirectionInverted; // Sets `mixerConfigMutable()->motorDirectionInverted`.
    uint8_t reserved1; // Ignored.
    uint8_t motorStopOnLow; // Sets `mixerConfigMutable()->motorstopOnLow`.
    uint8_t platformType; // Sets `mixerConfigMutable()->platformType`.
    uint8_t hasFlaps; // Sets `mixerConfigMutable()->hasFlaps`.
    uint16_t appliedMixerPreset; // Sets `mixerConfigMutable()->appliedMixerPreset`.
    uint8_t maxMotors; // Ignored.
    uint8_t maxServos; // Ignored.
} msp_MSP2_INAV_SET_MIXER_request_t;

#define MSP2_INAV_SET_MIXER_REQUEST_PAYLOAD_SIZE 9

// No reply payload for MSP2_INAV_SET_MIXER.

// MSP2_INAV_OSD_LAYOUTS
// Gets OSD layout information (counts, positions for a specific layout, or position for a specific item).
// Notes: Requires `USE_OSD`. Returns error if indexes are invalid.
// No request payload for MSP2_INAV_OSD_LAYOUTS.

typedef struct MSP_PACKED {
    uint8_t layoutCount; // Number of OSD layouts (`OSD_LAYOUT_COUNT`).
    uint8_t itemCount; // Number of OSD items per layout (`OSD_ITEM_COUNT`).
} msp_MSP2_INAV_OSD_LAYOUTS_reply_t;

#define MSP2_INAV_OSD_LAYOUTS_REPLY_PAYLOAD_SIZE 2

// MSP2_INAV_OSD_SET_LAYOUT_ITEM
// Sets the position of a single OSD item within a specific layout.
// Notes: Requires `USE_OSD`. Expects 4 bytes. Returns error if indexes are invalid. If the modified layout is not the currently active one, it temporarily overrides the active layout for 10 seconds to show the change. Otherwise, triggers a full OSD redraw.
typedef struct MSP_PACKED {
    uint8_t layoutIndex; // Index of the OSD layout (0 to `OSD_LAYOUT_COUNT - 1`).
    OSD_ITEM_* itemIndex; // Index of the OSD item (`OSD_ITEM_*` enum).
    uint16_t itemPosition; // Packed X/Y position (`(Y << 8)
} msp_MSP2_INAV_OSD_SET_LAYOUT_ITEM_request_t;

#define MSP2_INAV_OSD_SET_LAYOUT_ITEM_REQUEST_PAYLOAD_SIZE 4

// No reply payload for MSP2_INAV_OSD_SET_LAYOUT_ITEM.

// MSP2_INAV_OSD_ALARMS
// Retrieves OSD alarm threshold settings.
// Notes: Requires `USE_OSD`.
// No request payload for MSP2_INAV_OSD_ALARMS.

typedef struct MSP_PACKED {
    uint8_t rssiAlarm; // RSSI alarm threshold (`osdConfig()->rssi_alarm`).
    uint16_t timerAlarm; // Timer alarm threshold (`osdConfig()->time_alarm`).
    uint16_t altAlarm; // Altitude alarm threshold (`osdConfig()->alt_alarm`).
    uint16_t distAlarm; // Distance alarm threshold (`osdConfig()->dist_alarm`).
    uint16_t negAltAlarm; // Negative altitude alarm threshold (`osdConfig()->neg_alt_alarm`).
    uint16_t gForceAlarm; // G-force alarm threshold (`osdConfig()->gforce_alarm * 1000`).
    int16_t gForceAxisMinAlarm; // Min G-force per-axis alarm (`osdConfig()->gforce_axis_alarm_min * 1000`).
    int16_t gForceAxisMaxAlarm; // Max G-force per-axis alarm (`osdConfig()->gforce_axis_alarm_max * 1000`).
    uint8_t currentAlarm; // Current draw alarm threshold (`osdConfig()->current_alarm`). Units may need verification.
    uint16_t imuTempMinAlarm; // Min IMU temperature alarm (`osdConfig()->imu_temp_alarm_min`).
    uint16_t imuTempMaxAlarm; // Max IMU temperature alarm (`osdConfig()->imu_temp_alarm_max`).
    uint16_t baroTempMinAlarm; // Min Baro temperature alarm (`osdConfig()->baro_temp_alarm_min`). 0 if `USE_BARO` disabled.
    uint16_t baroTempMaxAlarm; // Max Baro temperature alarm (`osdConfig()->baro_temp_alarm_max`). 0 if `USE_BARO` disabled.
    uint16_t adsbWarnDistance; // ADSB warning distance (`osdConfig()->adsb_distance_warning`). 0 if `USE_ADSB` disabled.
    uint16_t adsbAlertDistance; // ADSB alert distance (`osdConfig()->adsb_distance_alert`). 0 if `USE_ADSB` disabled.
} msp_MSP2_INAV_OSD_ALARMS_reply_t;

#define MSP2_INAV_OSD_ALARMS_REPLY_PAYLOAD_SIZE 28

// MSP2_INAV_OSD_SET_ALARMS
// Sets OSD alarm threshold settings.
// Notes: Requires `USE_OSD`. Expects 24 bytes. ADSB alarms are not settable via this message.
typedef struct MSP_PACKED {
    uint8_t rssiAlarm; // Sets `osdConfigMutable()->rssi_alarm`.
    uint16_t timerAlarm; // Sets `osdConfigMutable()->time_alarm`.
    uint16_t altAlarm; // Sets `osdConfigMutable()->alt_alarm`.
    uint16_t distAlarm; // Sets `osdConfigMutable()->dist_alarm`.
    uint16_t negAltAlarm; // Sets `osdConfigMutable()->neg_alt_alarm`.
    uint16_t gForceAlarm; // Sets `osdConfigMutable()->gforce_alarm = value / 1000.0f`.
    int16_t gForceAxisMinAlarm; // Sets `osdConfigMutable()->gforce_axis_alarm_min = value / 1000.0f`.
    int16_t gForceAxisMaxAlarm; // Sets `osdConfigMutable()->gforce_axis_alarm_max = value / 1000.0f`.
    uint8_t currentAlarm; // Sets `osdConfigMutable()->current_alarm`.
    uint16_t imuTempMinAlarm; // Sets `osdConfigMutable()->imu_temp_alarm_min`.
    uint16_t imuTempMaxAlarm; // Sets `osdConfigMutable()->imu_temp_alarm_max`.
    uint16_t baroTempMinAlarm; // Sets `osdConfigMutable()->baro_temp_alarm_min` (if `USE_BARO`).
    uint16_t baroTempMaxAlarm; // Sets `osdConfigMutable()->baro_temp_alarm_max` (if `USE_BARO`).
} msp_MSP2_INAV_OSD_SET_ALARMS_request_t;

#define MSP2_INAV_OSD_SET_ALARMS_REQUEST_PAYLOAD_SIZE 24

// No reply payload for MSP2_INAV_OSD_SET_ALARMS.

// MSP2_INAV_OSD_PREFERENCES
// Retrieves OSD display preferences (video system, units, styles, etc.).
// Notes: Requires `USE_OSD`.
// No request payload for MSP2_INAV_OSD_PREFERENCES.

typedef struct MSP_PACKED {
    osdConfig()->video_system videoSystem; // Enum: Video system (Auto/PAL/NTSC) (`osdConfig()->video_system`).
    uint8_t mainVoltageDecimals; // Count: Decimal places for main voltage display (`osdConfig()->main_voltage_decimals`).
    uint8_t ahiReverseRoll; // Boolean: Reverse roll direction on Artificial Horizon (`osdConfig()->ahi_reverse_roll`).
    osdConfig()->crosshairs_style crosshairsStyle; // Enum: Style of the center crosshairs (`osdConfig()->crosshairs_style`).
    uint8_t leftSidebarScroll; // Boolean: Enable scrolling for left sidebar (`osdConfig()->left_sidebar_scroll`).
    uint8_t rightSidebarScroll; // Boolean: Enable scrolling for right sidebar (`osdConfig()->right_sidebar_scroll`).
    uint8_t sidebarScrollArrows; // Boolean: Show arrows for scrollable sidebars (`osdConfig()->sidebar_scroll_arrows`).
    osdConfig()->units units; // Enum: Measurement units (Metric/Imperial) (`osdConfig()->units`).
    osdConfig()->stats_energy_unit statsEnergyUnit; // Enum: Unit for energy display in post-flight stats (`osdConfig()->stats_energy_unit`).
} msp_MSP2_INAV_OSD_PREFERENCES_reply_t;

#define MSP2_INAV_OSD_PREFERENCES_REPLY_PAYLOAD_SIZE 9

// MSP2_INAV_OSD_SET_PREFERENCES
// Sets OSD display preferences.
// Notes: Requires `USE_OSD`. Expects 9 bytes. Triggers a full OSD redraw.
typedef struct MSP_PACKED {
    uint8_t videoSystem; // Sets `osdConfigMutable()->video_system`.
    uint8_t mainVoltageDecimals; // Sets `osdConfigMutable()->main_voltage_decimals`.
    uint8_t ahiReverseRoll; // Sets `osdConfigMutable()->ahi_reverse_roll`.
    uint8_t crosshairsStyle; // Sets `osdConfigMutable()->crosshairs_style`.
    uint8_t leftSidebarScroll; // Sets `osdConfigMutable()->left_sidebar_scroll`.
    uint8_t rightSidebarScroll; // Sets `osdConfigMutable()->right_sidebar_scroll`.
    uint8_t sidebarScrollArrows; // Sets `osdConfigMutable()->sidebar_scroll_arrows`.
    uint8_t units; // Sets `osdConfigMutable()->units`.
    uint8_t statsEnergyUnit; // Sets `osdConfigMutable()->stats_energy_unit`.
} msp_MSP2_INAV_OSD_SET_PREFERENCES_request_t;

#define MSP2_INAV_OSD_SET_PREFERENCES_REQUEST_PAYLOAD_SIZE 9

// No reply payload for MSP2_INAV_OSD_SET_PREFERENCES.

// MSP2_INAV_SELECT_BATTERY_PROFILE
// Selects the active battery profile and saves configuration.
// Notes: Expects 1 byte. Will fail if armed. Calls `setConfigBatteryProfileAndWriteEEPROM()`.
typedef struct MSP_PACKED {
    uint8_t batteryProfileIndex; // Index of the battery profile to activate (0-based).
} msp_MSP2_INAV_SELECT_BATTERY_PROFILE_request_t;

#define MSP2_INAV_SELECT_BATTERY_PROFILE_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP2_INAV_SELECT_BATTERY_PROFILE.

// MSP2_INAV_DEBUG
// Retrieves values from the firmware's 32-bit `debug[]` array. Supersedes `MSP_DEBUG`.
// Notes: `DEBUG32_VALUE_COUNT` is usually 8.
// No request payload for MSP2_INAV_DEBUG.

typedef struct MSP_PACKED {
    uint32_t[DEBUG32_VALUE_COUNT] debugValues; // Values from the `debug` array (typically 8 values).
} msp_MSP2_INAV_DEBUG_reply_t;

// #define MSP2_INAV_DEBUG_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_BLACKBOX_CONFIG
// Retrieves the Blackbox configuration. Supersedes `MSP_BLACKBOX_CONFIG`.
// Notes: Requires `USE_BLACKBOX`.
// No request payload for MSP2_BLACKBOX_CONFIG.

typedef struct MSP_PACKED {
    uint8_t blackboxSupported; // Boolean: 1 if Blackbox is supported (`USE_BLACKBOX`), 0 otherwise.
    blackboxDevice_e blackboxDevice; // Enum (`blackboxDevice_e`): Target device for logging (`blackboxConfig()->device`). 0 if not supported.
    uint16_t blackboxRateNum; // Numerator for logging rate divider (`blackboxConfig()->rate_num`). 0 if not supported.
    uint16_t blackboxRateDenom; // Denominator for logging rate divider (`blackboxConfig()->rate_denom`). 0 if not supported.
    uint32_t blackboxIncludeFlags; // Bitmask: Flags for fields included/excluded from logging (`blackboxConfig()->includeFlags`).
} msp_MSP2_BLACKBOX_CONFIG_reply_t;

#define MSP2_BLACKBOX_CONFIG_REPLY_PAYLOAD_SIZE 10

// MSP2_SET_BLACKBOX_CONFIG
// Sets the Blackbox configuration. Supersedes `MSP_SET_BLACKBOX_CONFIG`.
// Notes: Requires `USE_BLACKBOX`. Expects 9 bytes. Returns error if Blackbox is currently logging (`!blackboxMayEditConfig()`).
typedef struct MSP_PACKED {
    uint8_t blackboxDevice; // Sets `blackboxConfigMutable()->device`.
    uint16_t blackboxRateNum; // Sets `blackboxConfigMutable()->rate_num`.
    uint16_t blackboxRateDenom; // Sets `blackboxConfigMutable()->rate_denom`.
    uint32_t blackboxIncludeFlags; // Sets `blackboxConfigMutable()->includeFlags`.
} msp_MSP2_SET_BLACKBOX_CONFIG_request_t;

#define MSP2_SET_BLACKBOX_CONFIG_REQUEST_PAYLOAD_SIZE 9

// No reply payload for MSP2_SET_BLACKBOX_CONFIG.

// MSP2_INAV_TEMP_SENSOR_CONFIG
// Retrieves the configuration for all onboard temperature sensors.
// Notes: Requires `USE_TEMPERATURE_SENSOR`.
// No request payload for MSP2_INAV_TEMP_SENSOR_CONFIG.

typedef struct MSP_PACKED {
    tempSensorType_e type; // Enum (`tempSensorType_e`): Type of the temperature sensor.
    uint64_t address; // Sensor address/ID (e.g., for 1-Wire sensors).
    uint16_t alarmMin; // Min temperature alarm threshold (degrees C).
    uint16_t alarmMax; // Max temperature alarm threshold (degrees C).
    uint8_t osdSymbol; // Index: OSD symbol to use for this sensor (0 to `TEMP_SENSOR_SYM_COUNT`).
    char[TEMPERATURE_LABEL_LEN] label; // User-defined label for the sensor.
} msp_MSP2_INAV_TEMP_SENSOR_CONFIG_reply_t;

// #define MSP2_INAV_TEMP_SENSOR_CONFIG_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_INAV_SET_TEMP_SENSOR_CONFIG
// Sets the configuration for all onboard temperature sensors.
// Notes: Requires `USE_TEMPERATURE_SENSOR`. Expects `MAX_TEMP_SENSORS * sizeof(tempSensorConfig_t)` bytes.
typedef struct MSP_PACKED {
    uint8_t type; // Sets sensor type.
    uint64_t address; // Sets sensor address/ID.
    uint16_t alarmMin; // Sets min alarm threshold.
    uint16_t alarmMax; // Sets max alarm threshold.
    uint8_t osdSymbol; // Sets OSD symbol index (validated).
    char[TEMPERATURE_LABEL_LEN] label; // Sets sensor label (converted to uppercase).
} msp_MSP2_INAV_SET_TEMP_SENSOR_CONFIG_request_t;

// #define MSP2_INAV_SET_TEMP_SENSOR_CONFIG_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP2_INAV_SET_TEMP_SENSOR_CONFIG.

// MSP2_INAV_TEMPERATURES
// Retrieves the current readings from all configured temperature sensors.
// Notes: Requires `USE_TEMPERATURE_SENSOR`.
// No request payload for MSP2_INAV_TEMPERATURES.

typedef struct MSP_PACKED {
    int16_t temperature; // Current temperature reading. -1000 if sensor is invalid or reading failed.
} msp_MSP2_INAV_TEMPERATURES_reply_t;

#define MSP2_INAV_TEMPERATURES_REPLY_PAYLOAD_SIZE 2

// MSP_SIMULATOR
// Handles Hardware-in-the-Loop (HITL) simulation data exchange. Receives simulated sensor data and options, sends back control outputs and debug info.
// Notes: Requires `USE_SIMULATOR`. Complex message handling state changes for enabling/disabling HITL. Sensor data is injected directly. OSD data is sent using a custom RLE scheme. See `simulatorData` struct and associated code for details.
typedef struct MSP_PACKED {
    uint8_t simulatorVersion; // Version of the simulator protocol (`SIMULATOR_MSP_VERSION`).
    uint8_t hitlFlags; // Bitmask: Options for HITL (`HITL_*` flags).
    uint8_t gpsFixType; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated GPS fix type.
    uint8_t gpsNumSat; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated satellite count.
    uint32_t gpsLat; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated latitude (1e7 deg).
    uint32_t gpsLon; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated longitude (1e7 deg).
    uint32_t gpsAlt; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated altitude (cm).
    uint16_t gpsSpeed; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated ground speed (cm/s).
    uint16_t gpsCourse; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated ground course (deci-deg).
    int16_t gpsVelN; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated North velocity (cm/s).
    int16_t gpsVelE; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated East velocity (cm/s).
    int16_t gpsVelD; // (If `HITL_HAS_NEW_GPS_DATA`) Simulated Down velocity (cm/s).
    int16_t imuRoll; // (If NOT `HITL_USE_IMU`) Simulated Roll (deci-deg).
    int16_t imuPitch; // (If NOT `HITL_USE_IMU`) Simulated Pitch (deci-deg).
    int16_t imuYaw; // (If NOT `HITL_USE_IMU`) Simulated Yaw (deci-deg).
    int16_t accX; // mG (G * 1000)
    int16_t accY; // mG (G * 1000)
    int16_t accZ; // mG (G * 1000)
    int16_t gyroX; // dps * 16
    int16_t gyroY; // dps * 16
    int16_t gyroZ; // dps * 16
    uint32_t baroPressure; // Pa
    int16_t magX; // Scaled
    int16_t magY; // Scaled
    int16_t magZ; // Scaled
    uint8_t vbat; // (If `HITL_EXT_BATTERY_VOLTAGE`) Simulated battery voltage (0.1V units).
    uint16_t airspeed; // (If `HITL_AIRSPEED`) Simulated airspeed (cm/s).
    uint8_t extFlags; // (If `HITL_EXTENDED_FLAGS`) Additional flags (upper 8 bits).
} msp_MSP_SIMULATOR_request_t;

#define MSP_SIMULATOR_REQUEST_PAYLOAD_SIZE 58

typedef struct MSP_PACKED {
    uint16_t stabilizedRoll; // Stabilized Roll command output (-500 to 500).
    uint16_t stabilizedPitch; // Stabilized Pitch command output (-500 to 500).
    uint16_t stabilizedYaw; // Stabilized Yaw command output (-500 to 500).
    uint16_t stabilizedThrottle; // Stabilized Throttle command output (-500 to 500 if armed, else -500).
    uint8_t debugFlags; // Packed flags: Debug index (0-7), Platform type, Armed state, OSD feature status.
    uint32_t debugValue; // Current debug value (`debug[simulatorData.debugIndex]`).
    int16_t attitudeRoll; // Current estimated Roll (deci-deg).
    int16_t attitudePitch; // Current estimated Pitch (deci-deg).
    int16_t attitudeYaw; // Current estimated Yaw (deci-deg).
    uint8_t osdHeader; // OSD RLE Header (255).
    uint8_t osdRows; // (If OSD supported) Number of OSD rows.
    uint8_t osdCols; // (If OSD supported) Number of OSD columns.
    uint8_t osdStartY; // (If OSD supported) Starting row for RLE data.
    uint8_t osdStartX; // (If OSD supported) Starting column for RLE data.
    uint8_t[] osdRleData; // (If OSD supported) Run-length encoded OSD character data. Terminated by `[0, 0]`.
} msp_MSP_SIMULATOR_reply_t;

// #define MSP_SIMULATOR_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_INAV_SERVO_MIXER
// Retrieves the custom servo mixer rules, including programming framework condition IDs, for primary and secondary mixer profiles. Supersedes `MSP_SERVO_MIX_RULES`.
// Notes: `conditionId` requires `USE_PROGRAMMING_FRAMEWORK`.
// No request payload for MSP2_INAV_SERVO_MIXER.

// No reply payload for MSP2_INAV_SERVO_MIXER.

// MSP2_INAV_SET_SERVO_MIXER
// Sets a single custom servo mixer rule, including programming framework condition ID. Supersedes `MSP_SET_SERVO_MIX_RULE`.
// Notes: Expects 7 bytes. Returns error if index invalid. Calls `loadCustomServoMixer()`.
typedef struct MSP_PACKED {
    uint8_t ruleIndex; // Index of the rule to set (0 to `MAX_SERVO_RULES - 1`).
    uint8_t targetChannel; // Servo output channel index.
    mixerSource_t inputSource; // Enum: Input source (`mixerSource_t`).
    uint16_t rate; // Mixing rate/weight.
    uint8_t speed; // Speed/Slew rate limit (0-100).
    uint8_t conditionId; // Logic Condition ID (255/-1 if none). Ignored if `USE_PROGRAMMING_FRAMEWORK` is disabled.
} msp_MSP2_INAV_SET_SERVO_MIXER_request_t;

#define MSP2_INAV_SET_SERVO_MIXER_REQUEST_PAYLOAD_SIZE 7

// No reply payload for MSP2_INAV_SET_SERVO_MIXER.

// MSP2_INAV_LOGIC_CONDITIONS
// Retrieves the configuration of all defined Logic Conditions.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`. See `logicCondition_t` structure.
// No request payload for MSP2_INAV_LOGIC_CONDITIONS.

typedef struct MSP_PACKED {
    uint8_t enabled; // Boolean: 1 if the condition is enabled.
    uint8_t activatorId; // ID of the activator condition (if any, 255 if none).
    logicConditionOp_e operation; // Enum (`logicConditionOp_e`): Logical operation (AND, OR, XOR, etc.).
    logicOperandType_e operandAType; // Enum (`logicOperandType_e`): Type of the first operand (Flight Mode, GVAR, etc.).
    uint32_t operandAValue; // Value/ID of the first operand.
    logicOperandType_e operandBType; // Enum (`logicOperandType_e`): Type of the second operand.
    uint32_t operandBValue; // Value/ID of the second operand.
    uint8_t flags; // Bitmask: Condition flags (e.g., `LC_FLAG_FIRST_TIME_TRUE`).
} msp_MSP2_INAV_LOGIC_CONDITIONS_reply_t;

#define MSP2_INAV_LOGIC_CONDITIONS_REPLY_PAYLOAD_SIZE 14

// MSP2_INAV_SET_LOGIC_CONDITIONS
// Sets the configuration for a single Logic Condition by its index.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`. Expects 15 bytes. Returns error if index is invalid.
typedef struct MSP_PACKED {
    uint8_t conditionIndex; // Index of the condition to set (0 to `MAX_LOGIC_CONDITIONS - 1`).
    uint8_t enabled; // Boolean: 1 to enable the condition.
    uint8_t activatorId; // Activator condition ID.
    uint8_t operation; // Enum: Logical operation.
    uint8_t operandAType; // Enum: Type of operand A.
    uint32_t operandAValue; // Value/ID of operand A.
    uint8_t operandBType; // Enum: Type of operand B.
    uint32_t operandBValue; // Value/ID of operand B.
    uint8_t flags; // Bitmask: Condition flags.
} msp_MSP2_INAV_SET_LOGIC_CONDITIONS_request_t;

#define MSP2_INAV_SET_LOGIC_CONDITIONS_REQUEST_PAYLOAD_SIZE 15

// No reply payload for MSP2_INAV_SET_LOGIC_CONDITIONS.

// MSP2_INAV_GLOBAL_FUNCTIONS
// No request payload for MSP2_INAV_GLOBAL_FUNCTIONS.

// No reply payload for MSP2_INAV_GLOBAL_FUNCTIONS.

// MSP2_INAV_SET_GLOBAL_FUNCTIONS
// No request payload for MSP2_INAV_SET_GLOBAL_FUNCTIONS.

// No reply payload for MSP2_INAV_SET_GLOBAL_FUNCTIONS.

// MSP2_INAV_LOGIC_CONDITIONS_STATUS
// Retrieves the current evaluated status (true/false or numerical value) of all logic conditions.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`.
// No request payload for MSP2_INAV_LOGIC_CONDITIONS_STATUS.

typedef struct MSP_PACKED {
    uint32_t[MAX_LOGIC_CONDITIONS] conditionValues; // Array of current values for each logic condition (`logicConditionGetValue(i)`). 1 for true, 0 for false, or numerical value depending on operation.
} msp_MSP2_INAV_LOGIC_CONDITIONS_STATUS_reply_t;

// #define MSP2_INAV_LOGIC_CONDITIONS_STATUS_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_INAV_GVAR_STATUS
// Retrieves the current values of all Global Variables (GVARS).
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`.
// No request payload for MSP2_INAV_GVAR_STATUS.

typedef struct MSP_PACKED {
    uint32_t[MAX_GLOBAL_VARIABLES] gvarValues; // Array of current values for each global variable (`gvGet(i)`).
} msp_MSP2_INAV_GVAR_STATUS_reply_t;

// #define MSP2_INAV_GVAR_STATUS_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_INAV_PROGRAMMING_PID
// Retrieves the configuration of all Programming PIDs.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`. See `programmingPid_t` structure.
// No request payload for MSP2_INAV_PROGRAMMING_PID.

typedef struct MSP_PACKED {
    uint8_t enabled; // Boolean: 1 if the PID is enabled.
    logicOperandType_e setpointType; // Enum (`logicOperandType_e`): Type of the setpoint source.
    uint32_t setpointValue; // Value/ID of the setpoint source.
    logicOperandType_e measurementType; // Enum (`logicOperandType_e`): Type of the measurement source.
    uint32_t measurementValue; // Value/ID of the measurement source.
    uint16_t gainP; // Proportional gain.
    uint16_t gainI; // Integral gain.
    uint16_t gainD; // Derivative gain.
    uint16_t gainFF; // Feed-forward gain.
} msp_MSP2_INAV_PROGRAMMING_PID_reply_t;

#define MSP2_INAV_PROGRAMMING_PID_REPLY_PAYLOAD_SIZE 19

// MSP2_INAV_SET_PROGRAMMING_PID
// Sets the configuration for a single Programming PID by its index.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`. Expects 20 bytes. Returns error if index is invalid.
typedef struct MSP_PACKED {
    uint8_t pidIndex; // Index of the Programming PID to set (0 to `MAX_PROGRAMMING_PID_COUNT - 1`).
    uint8_t enabled; // Boolean: 1 to enable the PID.
    uint8_t setpointType; // Enum: Type of the setpoint source.
    uint32_t setpointValue; // Value/ID of the setpoint source.
    uint8_t measurementType; // Enum: Type of the measurement source.
    uint32_t measurementValue; // Value/ID of the measurement source.
    uint16_t gainP; // Proportional gain.
    uint16_t gainI; // Integral gain.
    uint16_t gainD; // Derivative gain.
    uint16_t gainFF; // Feed-forward gain.
} msp_MSP2_INAV_SET_PROGRAMMING_PID_request_t;

#define MSP2_INAV_SET_PROGRAMMING_PID_REQUEST_PAYLOAD_SIZE 20

// No reply payload for MSP2_INAV_SET_PROGRAMMING_PID.

// MSP2_INAV_PROGRAMMING_PID_STATUS
// Retrieves the current output value of all Programming PIDs.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`.
// No request payload for MSP2_INAV_PROGRAMMING_PID_STATUS.

typedef struct MSP_PACKED {
    uint32_t[MAX_PROGRAMMING_PID_COUNT] pidOutputs; // Array of current output values for each Programming PID (`programmingPidGetOutput(i)`).
} msp_MSP2_INAV_PROGRAMMING_PID_STATUS_reply_t;

// #define MSP2_INAV_PROGRAMMING_PID_STATUS_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_PID
// Retrieves the standard PID controller gains (P, I, D, FF) for the current PID profile.
// Notes: `PID_ITEM_COUNT` defines the number of standard PID controllers (Roll, Pitch, Yaw, Alt, Vel, etc.). Updates from EZ-Tune if enabled.
// No request payload for MSP2_PID.

typedef struct MSP_PACKED {
    uint8_t P; // Proportional gain (`pidBank()->pid[i].P`), constrained 0-255.
    uint8_t I; // Integral gain (`pidBank()->pid[i].I`), constrained 0-255.
    uint8_t D; // Derivative gain (`pidBank()->pid[i].D`), constrained 0-255.
    uint8_t FF; // Feed-forward gain (`pidBank()->pid[i].FF`), constrained 0-255.
} msp_MSP2_PID_reply_t;

#define MSP2_PID_REPLY_PAYLOAD_SIZE 4

// MSP2_SET_PID
// Sets the standard PID controller gains (P, I, D, FF) for the current PID profile.
// Notes: Expects `PID_ITEM_COUNT * 4` bytes. Calls `schedulePidGainsUpdate()` and `navigationUsePIDs()`.
typedef struct MSP_PACKED {
    uint8_t P; // Sets Proportional gain (`pidBankMutable()->pid[i].P`).
    uint8_t I; // Sets Integral gain (`pidBankMutable()->pid[i].I`).
    uint8_t D; // Sets Derivative gain (`pidBankMutable()->pid[i].D`).
    uint8_t FF; // Sets Feed-forward gain (`pidBankMutable()->pid[i].FF`).
} msp_MSP2_SET_PID_request_t;

#define MSP2_SET_PID_REQUEST_PAYLOAD_SIZE 4

// No reply payload for MSP2_SET_PID.

// MSP2_INAV_OPFLOW_CALIBRATION
// Starts the optical flow sensor calibration procedure.
// Notes: Requires `USE_OPFLOW`. Will fail if armed. Calls `opflowStartCalibration()`.
// No request payload for MSP2_INAV_OPFLOW_CALIBRATION.

// No reply payload for MSP2_INAV_OPFLOW_CALIBRATION.

// MSP2_INAV_FWUPDT_PREPARE
// Prepares the flight controller to receive a firmware update via MSP.
// Notes: Requires `MSP_FIRMWARE_UPDATE`. Expects 4 bytes. Returns error if preparation fails (e.g., no storage, invalid size). Calls `firmwareUpdatePrepare()`.
typedef struct MSP_PACKED {
    uint32_t firmwareSize; // Total size of the incoming firmware file in bytes.
} msp_MSP2_INAV_FWUPDT_PREPARE_request_t;

#define MSP2_INAV_FWUPDT_PREPARE_REQUEST_PAYLOAD_SIZE 4

// No reply payload for MSP2_INAV_FWUPDT_PREPARE.

// MSP2_INAV_FWUPDT_STORE
// Stores a chunk of firmware data received via MSP.
// Notes: Requires `MSP_FIRMWARE_UPDATE`. Returns error if storage fails (e.g., out of space, checksum error). Called repeatedly until the entire firmware is transferred. Calls `firmwareUpdateStore()`.
typedef struct MSP_PACKED {
    uint8_t[] firmwareChunk; // Chunk of firmware data.
} msp_MSP2_INAV_FWUPDT_STORE_request_t;

// #define MSP2_INAV_FWUPDT_STORE_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP2_INAV_FWUPDT_STORE.

// MSP2_INAV_FWUPDT_EXEC
// Executes the firmware update process (flashes the stored firmware and reboots).
// Notes: Requires `MSP_FIRMWARE_UPDATE`. Expects 1 byte. Returns error if update cannot start (e.g., not fully received). Calls `firmwareUpdateExec()`. If successful, the device will reboot into the new firmware.
typedef struct MSP_PACKED {
    uint8_t updateType; // Type of update (e.g., full flash, specific section - currently ignored/unused).
} msp_MSP2_INAV_FWUPDT_EXEC_request_t;

#define MSP2_INAV_FWUPDT_EXEC_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP2_INAV_FWUPDT_EXEC.

// MSP2_INAV_FWUPDT_ROLLBACK_PREPARE
// Prepares the flight controller to perform a firmware rollback to the previously stored version.
// Notes: Requires `MSP_FIRMWARE_UPDATE`. Returns error if rollback preparation fails (e.g., no rollback image available). Calls `firmwareUpdateRollbackPrepare()`.
// No request payload for MSP2_INAV_FWUPDT_ROLLBACK_PREPARE.

// No reply payload for MSP2_INAV_FWUPDT_ROLLBACK_PREPARE.

// MSP2_INAV_FWUPDT_ROLLBACK_EXEC
// Executes the firmware rollback process (flashes the stored backup firmware and reboots).
// Notes: Requires `MSP_FIRMWARE_UPDATE`. Returns error if rollback cannot start. Calls `firmwareUpdateRollbackExec()`. If successful, the device will reboot into the backup firmware.
// No request payload for MSP2_INAV_FWUPDT_ROLLBACK_EXEC.

// No reply payload for MSP2_INAV_FWUPDT_ROLLBACK_EXEC.

// MSP2_INAV_SAFEHOME
// Get or Set configuration for a specific Safe Home location.
// Notes: Requires `USE_SAFE_HOME`. Used by `mspFcSafeHomeOutCommand`. See `MSP2_INAV_SET_SAFEHOME` for setting.
typedef struct MSP_PACKED {
    uint8_t safehomeIndex; // Index of the safe home location (0 to `MAX_SAFE_HOMES - 1`).
} msp_MSP2_INAV_SAFEHOME_request_t;

#define MSP2_INAV_SAFEHOME_REQUEST_PAYLOAD_SIZE 1

typedef struct MSP_PACKED {
    uint8_t safehomeIndex; // Index requested.
    uint8_t enabled; // Boolean: 1 if this safe home is enabled.
    int32_t latitude; // Latitude (1e7 deg).
    int32_t longitude; // Longitude (1e7 deg).
} msp_MSP2_INAV_SAFEHOME_reply_t;

#define MSP2_INAV_SAFEHOME_REPLY_PAYLOAD_SIZE 10

// MSP2_INAV_SET_SAFEHOME
// Sets the configuration for a specific Safe Home location.
// Notes: Requires `USE_SAFE_HOME`. Expects 10 bytes. Returns error if index invalid. Resets corresponding FW autoland approach if `USE_FW_AUTOLAND` is enabled.
typedef struct MSP_PACKED {
    uint8_t safehomeIndex; // Index of the safe home location (0 to `MAX_SAFE_HOMES - 1`).
    uint8_t enabled; // Boolean: 1 to enable this safe home.
    int32_t latitude; // Latitude (1e7 deg).
    int32_t longitude; // Longitude (1e7 deg).
} msp_MSP2_INAV_SET_SAFEHOME_request_t;

#define MSP2_INAV_SET_SAFEHOME_REQUEST_PAYLOAD_SIZE 10

// No reply payload for MSP2_INAV_SET_SAFEHOME.

// MSP2_INAV_MISC2
// Retrieves miscellaneous runtime information including timers and throttle status.
// No request payload for MSP2_INAV_MISC2.

typedef struct MSP_PACKED {
    uint32_t uptimeSeconds; // Time since boot (`micros() / 1000000`).
    uint32_t flightTimeSeconds; // Accumulated flight time (`getFlightTime()`).
    uint8_t throttlePercent; // Current throttle output percentage (`getThrottlePercent(true)`).
    uint8_t autoThrottleFlag; // 1 if navigation is controlling throttle, 0 otherwise (`navigationIsControllingThrottle()`).
} msp_MSP2_INAV_MISC2_reply_t;

#define MSP2_INAV_MISC2_REPLY_PAYLOAD_SIZE 10

// MSP2_INAV_LOGIC_CONDITIONS_SINGLE
// Gets the configuration for a single Logic Condition by its index.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`. Used by `mspFcLogicConditionCommand`.
typedef struct MSP_PACKED {
    uint8_t conditionIndex; // Index of the condition to retrieve (0 to `MAX_LOGIC_CONDITIONS - 1`).
} msp_MSP2_INAV_LOGIC_CONDITIONS_SINGLE_request_t;

#define MSP2_INAV_LOGIC_CONDITIONS_SINGLE_REQUEST_PAYLOAD_SIZE 1

typedef struct MSP_PACKED {
    uint8_t enabled; // Boolean: 1 if enabled.
    uint8_t activatorId; // Activator ID.
    uint8_t operation; // Enum: Logical operation.
    uint8_t operandAType; // Enum: Type of operand A.
    uint32_t operandAValue; // Value/ID of operand A.
    uint8_t operandBType; // Enum: Type of operand B.
    uint32_t operandBValue; // Value/ID of operand B.
    uint8_t flags; // Bitmask: Condition flags.
} msp_MSP2_INAV_LOGIC_CONDITIONS_SINGLE_reply_t;

#define MSP2_INAV_LOGIC_CONDITIONS_SINGLE_REPLY_PAYLOAD_SIZE 14

// MSP2_INAV_ESC_RPM
// Retrieves the RPM reported by each ESC via telemetry.
// Notes: Requires `USE_ESC_SENSOR`. Payload size depends on the number of detected motors with telemetry.
// No request payload for MSP2_INAV_ESC_RPM.

typedef struct MSP_PACKED {
    uint32_t escRpm; // RPM reported by the ESC.
} msp_MSP2_INAV_ESC_RPM_reply_t;

#define MSP2_INAV_ESC_RPM_REPLY_PAYLOAD_SIZE 4

// MSP2_INAV_ESC_TELEM
// Retrieves the full telemetry data structure reported by each ESC.
// Notes: Requires `USE_ESC_SENSOR`. See `escSensorData_t` in `sensors/esc_sensor.h` for the exact structure fields.
// No request payload for MSP2_INAV_ESC_TELEM.

typedef struct MSP_PACKED {
    uint8_t motorCount; // Number of motors reporting telemetry (`getMotorCount()`).
    escSensorData_t[] escData; // Array of `escSensorData_t` structures containing voltage, current, temp, RPM, errors etc. for each ESC.
} msp_MSP2_INAV_ESC_TELEM_reply_t;

// #define MSP2_INAV_ESC_TELEM_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_INAV_LED_STRIP_CONFIG_EX
// Retrieves the full configuration for each LED on the strip using the `ledConfig_t` structure. Supersedes `MSP_LED_STRIP_CONFIG`.
// Notes: Requires `USE_LED_STRIP`. See `ledConfig_t` in `io/ledstrip.h` for structure fields (position, function, overlay, color, direction, params).
// No request payload for MSP2_INAV_LED_STRIP_CONFIG_EX.

typedef struct MSP_PACKED {
    ledConfig_t ledConfig; // Full configuration structure for the LED.
} msp_MSP2_INAV_LED_STRIP_CONFIG_EX_reply_t;

// #define MSP2_INAV_LED_STRIP_CONFIG_EX_REPLY_PAYLOAD_SIZE  /* variable or unknown size */

// MSP2_INAV_SET_LED_STRIP_CONFIG_EX
// Sets the configuration for a single LED on the strip using the `ledConfig_t` structure. Supersedes `MSP_SET_LED_STRIP_CONFIG`.
// Notes: Requires `USE_LED_STRIP`. Expects `1 + sizeof(ledConfig_t)` bytes. Returns error if index invalid. Calls `reevaluateLedConfig()`.
typedef struct MSP_PACKED {
    uint8_t ledIndex; // Index of the LED to configure (0 to `LED_MAX_STRIP_LENGTH - 1`).
    ledConfig_t ledConfig; // Full configuration structure for the LED.
} msp_MSP2_INAV_SET_LED_STRIP_CONFIG_EX_request_t;

// #define MSP2_INAV_SET_LED_STRIP_CONFIG_EX_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP2_INAV_SET_LED_STRIP_CONFIG_EX.

// MSP2_INAV_FW_APPROACH
// Get or Set configuration for a specific Fixed Wing Autoland approach.
// Notes: Requires `USE_FW_AUTOLAND`. Used by `mspFwApproachOutCommand`. See `MSP2_INAV_SET_FW_APPROACH` for setting.
typedef struct MSP_PACKED {
    uint8_t approachIndex; // Index of the approach setting (0 to `MAX_FW_LAND_APPOACH_SETTINGS - 1`).
} msp_MSP2_INAV_FW_APPROACH_request_t;

#define MSP2_INAV_FW_APPROACH_REQUEST_PAYLOAD_SIZE 1

typedef struct MSP_PACKED {
    uint8_t approachIndex; // Index requested.
    uint32_t approachAlt; // Altitude for the approach phase.
    uint32_t landAlt; // Altitude for the final landing phase.
    uint8_t approachDirection; // Direction of approach (From WP, Specific Heading).
    int16_t landHeading1; // Primary landing heading (if approachDirection requires it).
    int16_t landHeading2; // Secondary landing heading (if approachDirection requires it).
    uint8_t isSeaLevelRef; // 1 if altitudes are relative to sea level, 0 if relative to home.
} msp_MSP2_INAV_FW_APPROACH_reply_t;

#define MSP2_INAV_FW_APPROACH_REPLY_PAYLOAD_SIZE 15

// MSP2_INAV_SET_FW_APPROACH
// Sets the configuration for a specific Fixed Wing Autoland approach.
// Notes: Requires `USE_FW_AUTOLAND`. Expects 15 bytes. Returns error if index invalid.
typedef struct MSP_PACKED {
    uint8_t approachIndex; // Index of the approach setting (0 to `MAX_FW_LAND_APPOACH_SETTINGS - 1`).
    uint32_t approachAlt; // Sets approach altitude.
    uint32_t landAlt; // Sets landing altitude.
    uint8_t approachDirection; // Sets approach direction.
    int16_t landHeading1; // Sets primary landing heading.
    int16_t landHeading2; // Sets secondary landing heading.
    uint8_t isSeaLevelRef; // Sets altitude reference.
} msp_MSP2_INAV_SET_FW_APPROACH_request_t;

#define MSP2_INAV_SET_FW_APPROACH_REQUEST_PAYLOAD_SIZE 15

// No reply payload for MSP2_INAV_SET_FW_APPROACH.

// MSP2_INAV_GPS_UBLOX_COMMAND
// Sends a raw command directly to a U-Blox GPS module connected to the FC.
// Notes: Requires GPS feature enabled (`FEATURE_GPS`) and the GPS driver to be U-Blox (`isGpsUblox()`). Payload must be at least 8 bytes (minimum UBX frame size). Use with extreme caution, incorrect commands can misconfigure the GPS module. Calls `gpsUbloxSendCommand()`.
typedef struct MSP_PACKED {
    uint8_t[] ubxCommand; // Raw U-Blox UBX protocol command frame (including header, class, ID, length, payload, checksum).
} msp_MSP2_INAV_GPS_UBLOX_COMMAND_request_t;

// #define MSP2_INAV_GPS_UBLOX_COMMAND_REQUEST_PAYLOAD_SIZE  /* variable or unknown size */

// No reply payload for MSP2_INAV_GPS_UBLOX_COMMAND.

// MSP2_INAV_RATE_DYNAMICS
// Retrieves Rate Dynamics configuration parameters for the current control rate profile.
// Notes: Requires `USE_RATE_DYNAMICS`.
// No request payload for MSP2_INAV_RATE_DYNAMICS.

typedef struct MSP_PACKED {
    uint8_t sensitivityCenter; // Sensitivity at stick center (`currentControlRateProfile->rateDynamics.sensitivityCenter`).
    uint8_t sensitivityEnd; // Sensitivity at stick ends (`currentControlRateProfile->rateDynamics.sensitivityEnd`).
    uint8_t correctionCenter; // Correction strength at stick center (`currentControlRateProfile->rateDynamics.correctionCenter`).
    uint8_t correctionEnd; // Correction strength at stick ends (`currentControlRateProfile->rateDynamics.correctionEnd`).
    uint8_t weightCenter; // Transition weight at stick center (`currentControlRateProfile->rateDynamics.weightCenter`).
    uint8_t weightEnd; // Transition weight at stick ends (`currentControlRateProfile->rateDynamics.weightEnd`).
} msp_MSP2_INAV_RATE_DYNAMICS_reply_t;

#define MSP2_INAV_RATE_DYNAMICS_REPLY_PAYLOAD_SIZE 6

// MSP2_INAV_SET_RATE_DYNAMICS
// Sets Rate Dynamics configuration parameters for the current control rate profile.
// Notes: Requires `USE_RATE_DYNAMICS`. Expects 6 bytes.
typedef struct MSP_PACKED {
    uint8_t sensitivityCenter; // Sets sensitivity at center.
    uint8_t sensitivityEnd; // Sets sensitivity at ends.
    uint8_t correctionCenter; // Sets correction at center.
    uint8_t correctionEnd; // Sets correction at ends.
    uint8_t weightCenter; // Sets weight at center.
    uint8_t weightEnd; // Sets weight at ends.
} msp_MSP2_INAV_SET_RATE_DYNAMICS_request_t;

#define MSP2_INAV_SET_RATE_DYNAMICS_REQUEST_PAYLOAD_SIZE 6

// No reply payload for MSP2_INAV_SET_RATE_DYNAMICS.

// MSP2_INAV_EZ_TUNE
// Retrieves the current EZ-Tune parameters.
// Notes: Requires `USE_EZ_TUNE`. Calls `ezTuneUpdate()` before sending.
// No request payload for MSP2_INAV_EZ_TUNE.

typedef struct MSP_PACKED {
    uint8_t enabled; // Boolean: 1 if EZ-Tune is enabled (`ezTune()->enabled`).
    uint16_t filterHz; // Filter frequency used during tuning (`ezTune()->filterHz`).
    uint8_t axisRatio; // Roll vs Pitch axis tuning ratio (`ezTune()->axisRatio`).
    uint8_t response; // Desired response characteristic (`ezTune()->response`).
    uint8_t damping; // Desired damping characteristic (`ezTune()->damping`).
    uint8_t stability; // Stability preference (`ezTune()->stability`).
    uint8_t aggressiveness; // Aggressiveness preference (`ezTune()->aggressiveness`).
    uint8_t rate; // Resulting rate setting (`ezTune()->rate`).
    uint8_t expo; // Resulting expo setting (`ezTune()->expo`).
    uint8_t snappiness; // Snappiness preference (`ezTune()->snappiness`).
} msp_MSP2_INAV_EZ_TUNE_reply_t;

#define MSP2_INAV_EZ_TUNE_REPLY_PAYLOAD_SIZE 11

// MSP2_INAV_EZ_TUNE_SET
// Sets the EZ-Tune parameters and triggers an update.
// Notes: Requires `USE_EZ_TUNE`. Expects 10 or 11 bytes. Calls `ezTuneUpdate()` after setting parameters.
typedef struct MSP_PACKED {
    uint8_t enabled; // Sets enabled state.
    uint16_t filterHz; // Sets filter frequency.
    uint8_t axisRatio; // Sets axis ratio.
    uint8_t response; // Sets response characteristic.
    uint8_t damping; // Sets damping characteristic.
    uint8_t stability; // Sets stability preference.
    uint8_t aggressiveness; // Sets aggressiveness preference.
    uint8_t rate; // Sets rate setting.
    uint8_t expo; // Sets expo setting.
    uint8_t snappiness; // (Optional) Sets snappiness preference.
} msp_MSP2_INAV_EZ_TUNE_SET_request_t;

#define MSP2_INAV_EZ_TUNE_SET_REQUEST_PAYLOAD_SIZE 11

// No reply payload for MSP2_INAV_EZ_TUNE_SET.

// MSP2_INAV_SELECT_MIXER_PROFILE
// Selects the active mixer profile and saves configuration.
// Notes: Expects 1 byte. Will fail if armed. Calls `setConfigMixerProfileAndWriteEEPROM()`. Only applicable if `MAX_MIXER_PROFILE_COUNT` > 1.
typedef struct MSP_PACKED {
    uint8_t mixerProfileIndex; // Index of the mixer profile to activate (0-based).
} msp_MSP2_INAV_SELECT_MIXER_PROFILE_request_t;

#define MSP2_INAV_SELECT_MIXER_PROFILE_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP2_INAV_SELECT_MIXER_PROFILE.

// MSP2_ADSB_VEHICLE_LIST
// Retrieves the list of currently tracked ADSB (Automatic Dependent Surveillance–Broadcast) vehicles.
// Notes: Requires `USE_ADSB`.
// No request payload for MSP2_ADSB_VEHICLE_LIST.

// No reply payload for MSP2_ADSB_VEHICLE_LIST.

// MSP2_INAV_CUSTOM_OSD_ELEMENTS
// Retrieves counts related to custom OSD elements defined by the programming framework.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`.
// No request payload for MSP2_INAV_CUSTOM_OSD_ELEMENTS.

typedef struct MSP_PACKED {
    uint8_t maxElements; // Maximum number of custom elements (`MAX_CUSTOM_ELEMENTS`).
    uint8_t maxTextLength; // Maximum length of the text part (`OSD_CUSTOM_ELEMENT_TEXT_SIZE - 1`).
    uint8_t maxParts; // Maximum number of parts per element (`CUSTOM_ELEMENTS_PARTS`).
} msp_MSP2_INAV_CUSTOM_OSD_ELEMENTS_reply_t;

#define MSP2_INAV_CUSTOM_OSD_ELEMENTS_REPLY_PAYLOAD_SIZE 3

// MSP2_INAV_CUSTOM_OSD_ELEMENT
// Gets the configuration of a single custom OSD element defined by the programming framework.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`. See `osdCustomElement_t`.
typedef struct MSP_PACKED {
    uint8_t elementIndex; // Index of the custom element (0 to `MAX_CUSTOM_ELEMENTS - 1`).
} msp_MSP2_INAV_CUSTOM_OSD_ELEMENT_request_t;

#define MSP2_INAV_CUSTOM_OSD_ELEMENT_REQUEST_PAYLOAD_SIZE 1

// No reply payload for MSP2_INAV_CUSTOM_OSD_ELEMENT.

// MSP2_INAV_SET_CUSTOM_OSD_ELEMENTS
// Sets the configuration of a single custom OSD element defined by the programming framework.
// Notes: Requires `USE_PROGRAMMING_FRAMEWORK`. Expects `1 + (CUSTOM_ELEMENTS_PARTS * 3) + 3 + (OSD_CUSTOM_ELEMENT_TEXT_SIZE - 1)` bytes. Returns error if index or part type is invalid. Null-terminates the text internally.
// No request payload for MSP2_INAV_SET_CUSTOM_OSD_ELEMENTS.

// No reply payload for MSP2_INAV_SET_CUSTOM_OSD_ELEMENTS.

// MSP2_INAV_OUTPUT_MAPPING_EXT2
// Retrieves the full extended output mapping configuration (timer ID, full 32-bit usage flags, and pin label). Supersedes `MSP2_INAV_OUTPUT_MAPPING_EXT`.
// Notes: Provides complete usage flags and helps identify pins repurposed for functions like LED strip.
// No request payload for MSP2_INAV_OUTPUT_MAPPING_EXT2.

typedef struct MSP_PACKED {
    uint8_t timerId; // Hardware timer identifier (e.g., `TIM1`, `TIM2`). SITL uses index.
    uint32_t usageFlags; // Full 32-bit timer usage flags (`TIM_USE_*`).
    PIN_LABEL_* pinLabel; // Label for special pin usage (`PIN_LABEL_*` enum, e.g., `PIN_LABEL_LED`). 0 (`PIN_LABEL_NONE`) otherwise.
} msp_MSP2_INAV_OUTPUT_MAPPING_EXT2_reply_t;

#define MSP2_INAV_OUTPUT_MAPPING_EXT2_REPLY_PAYLOAD_SIZE 6

// MSP2_INAV_SERVO_CONFIG
// Retrieves the configuration parameters for all supported servos (min, max, middle, rate). Supersedes `MSP_SERVO_CONFIGURATIONS`.
// No request payload for MSP2_INAV_SERVO_CONFIG.

typedef struct MSP_PACKED {
    uint16_t min; // Minimum servo endpoint (`servoParams(i)->min`).
    uint16_t max; // Maximum servo endpoint (`servoParams(i)->max`).
    uint16_t middle; // Middle/Neutral servo position (`servoParams(i)->middle`).
    uint8_t rate; // Servo rate/scaling (`servoParams(i)->rate`).
} msp_MSP2_INAV_SERVO_CONFIG_reply_t;

#define MSP2_INAV_SERVO_CONFIG_REPLY_PAYLOAD_SIZE 7

// MSP2_INAV_SET_SERVO_CONFIG
// Sets the configuration parameters for a single servo. Supersedes `MSP_SET_SERVO_CONFIGURATION`.
// Notes: Expects 8 bytes. Returns error if index invalid. Calls `servoComputeScalingFactors()`.
typedef struct MSP_PACKED {
    uint8_t servoIndex; // Index of the servo to configure (0 to `MAX_SUPPORTED_SERVOS - 1`).
    uint16_t min; // Sets minimum servo endpoint.
    uint16_t max; // Sets maximum servo endpoint.
    uint16_t middle; // Sets middle/neutral servo position.
    uint8_t rate; // Sets servo rate/scaling.
} msp_MSP2_INAV_SET_SERVO_CONFIG_request_t;

#define MSP2_INAV_SET_SERVO_CONFIG_REQUEST_PAYLOAD_SIZE 8

// No reply payload for MSP2_INAV_SET_SERVO_CONFIG.

// MSP2_INAV_GEOZONE
// Get configuration for a specific Geozone.
// Notes: Requires `USE_GEOZONE`. Used by `mspFcGeozoneOutCommand`.
typedef struct MSP_PACKED {
    uint8_t geozoneIndex; // Index of the geozone (0 to `MAX_GEOZONES_IN_CONFIG - 1`).
} msp_MSP2_INAV_GEOZONE_request_t;

#define MSP2_INAV_GEOZONE_REQUEST_PAYLOAD_SIZE 1

typedef struct MSP_PACKED {
    uint8_t geozoneIndex; // Index requested.
    GEOZONE_TYPE_* type; // Enum (`GEOZONE_TYPE_*`): Zone type (Inclusion/Exclusion).
    GEOZONE_SHAPE_* shape; // Enum (`GEOZONE_SHAPE_*`): Zone shape (Polygon/Circular).
    uint32_t minAltitude; // Minimum allowed altitude within the zone (cm).
    uint32_t maxAltitude; // Maximum allowed altitude within the zone (cm).
    uint8_t isSeaLevelRef; // Boolean: 1 if altitudes are relative to sea level, 0 if relative to home.
    GEOZONE_ACTION_* fenceAction; // Enum (`GEOZONE_ACTION_*`): Action to take upon boundary violation.
    uint8_t vertexCount; // Number of vertices defined for this zone.
} msp_MSP2_INAV_GEOZONE_reply_t;

#define MSP2_INAV_GEOZONE_REPLY_PAYLOAD_SIZE 14

// MSP2_INAV_SET_GEOZONE
// Sets the main configuration for a specific Geozone (type, shape, altitude, action). **This command resets (clears) all vertices associated with the zone.**
// Notes: Requires `USE_GEOZONE`. Expects 14 bytes. Returns error if index invalid. Calls `geozoneResetVertices()`. Vertices must be set subsequently using `MSP2_INAV_SET_GEOZONE_VERTEX`.
typedef struct MSP_PACKED {
    uint8_t geozoneIndex; // Index of the geozone (0 to `MAX_GEOZONES_IN_CONFIG - 1`).
    GEOZONE_TYPE_* type; // Enum (`GEOZONE_TYPE_*`): Zone type.
    GEOZONE_SHAPE_* shape; // Enum (`GEOZONE_SHAPE_*`): Zone shape.
    uint32_t minAltitude; // Minimum allowed altitude (cm).
    uint32_t maxAltitude; // Maximum allowed altitude (cm).
    uint8_t isSeaLevelRef; // Boolean: Altitude reference.
    GEOZONE_ACTION_* fenceAction; // Enum (`GEOZONE_ACTION_*`): Fence action.
    uint8_t vertexCount; // Number of vertices to be defined (used for validation later).
} msp_MSP2_INAV_SET_GEOZONE_request_t;

#define MSP2_INAV_SET_GEOZONE_REQUEST_PAYLOAD_SIZE 14

// No reply payload for MSP2_INAV_SET_GEOZONE.

// MSP2_INAV_GEOZONE_VERTEX
// Get a specific vertex (or center+radius for circular zones) of a Geozone.
// Notes: Requires `USE_GEOZONE`. Returns error if indexes are invalid or vertex doesn't exist. For circular zones, the radius is stored internally as the 'latitude' of the vertex with index 1.
typedef struct MSP_PACKED {
    uint8_t geozoneIndex; // Index of the geozone.
    uint8_t vertexId; // Index of the vertex within the zone (0-based). For circles, 0 = center.
} msp_MSP2_INAV_GEOZONE_VERTEX_request_t;

#define MSP2_INAV_GEOZONE_VERTEX_REQUEST_PAYLOAD_SIZE 2

typedef struct MSP_PACKED {
    uint8_t geozoneIndex; // Geozone index requested.
    uint8_t vertexId; // Vertex index requested.
    int32_t latitude; // Vertex latitude.
    int32_t longitude; // Vertex longitude.
} msp_MSP2_INAV_GEOZONE_VERTEX_reply_t;

#define MSP2_INAV_GEOZONE_VERTEX_REPLY_PAYLOAD_SIZE 10

// MSP2_INAV_SET_GEOZONE_VERTEX
// Sets a specific vertex (or center+radius for circular zones) for a Geozone.
// Notes: Requires `USE_GEOZONE`. Expects 10 bytes (Polygon) or 14 bytes (Circular). Returns error if indexes invalid or if trying to set vertex beyond `vertexCount` defined in `MSP2_INAV_SET_GEOZONE`. Calls `geozoneSetVertex()`. For circular zones, sets center (vertex 0) and radius (vertex 1's latitude).
// No request payload for MSP2_INAV_SET_GEOZONE_VERTEX.

// No reply payload for MSP2_INAV_SET_GEOZONE_VERTEX.

// MSP2_BETAFLIGHT_BIND
// Initiates the receiver binding procedure for supported serial protocols (CRSF, SRXL2).
// Notes: Requires `rxConfig()->receiverType == RX_TYPE_SERIAL`. Requires `USE_SERIALRX_CRSF` or `USE_SERIALRX_SRXL2`. Calls `crsfBind()` or `srxl2Bind()` respectively. Returns error if receiver type or provider is not supported for binding.
// No request payload for MSP2_BETAFLIGHT_BIND.

// No reply payload for MSP2_BETAFLIGHT_BIND.

// ------- Generation warnings -------
// [MSP2_COMMON_SETTING_INFO reply] NOTE: JSON requested flexible array 'settingName[]' not in final position. Using char[1] placeholder. Real payload is variable.
// [MSP2_COMMON_SETTING_INFO reply] NOTE: JSON requested flexible array 'lookupNames[]' not in final position. Using char[1] placeholder. Real payload is variable.

#ifdef __cplusplus
} // extern "C"
#endif

#if defined(_MSC_VER)
  #pragma pack(pop)
#endif

#endif // MSP_GENERATED_H
